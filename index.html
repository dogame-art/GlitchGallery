<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GG - Glitch Gallery</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #fff;
            overflow-x: hidden;
        }
        header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(10,10,10,0.95);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #222;
        }
        h1 {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        h1.logo {
            font-size: 2.2rem;
            font-weight: 900;
            background: linear-gradient(135deg, #ff006e 0%, #8338ec 50%, #3a86ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glitch-text 3s infinite, logo-flicker 5s infinite;
            position: relative;
            letter-spacing: -3px;
            padding: 5px 12px;
            border: 2px solid transparent;
            background-clip: padding-box, border-box;
            background-origin: padding-box, border-box;
            background-image: linear-gradient(#0a0a0a, #0a0a0a), linear-gradient(135deg, #ff006e, #8338ec, #3a86ff);
            -webkit-background-clip: text, border-box;
        }
        h1.logo::before {
            content: 'GG';
            position: absolute;
            left: 12px;
            top: 5px;
            color: #ff006e;
            opacity: 0;
            animation: logo-ghost 4s infinite;
            -webkit-text-fill-color: #ff006e;
        }
        h1.logo::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 4px;
            padding: 2px;
            background: linear-gradient(135deg, #ff006e, #8338ec, #3a86ff);
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            opacity: 0.6;
        }
        .logo-text {
            font-size: 0.75rem;
            font-weight: 400;
            letter-spacing: 4px;
            opacity: 0.6;
            text-transform: uppercase;
        }
        @keyframes logo-flicker {
            0%, 95%, 100% { filter: none; }
            96% { filter: brightness(1.5) hue-rotate(10deg); }
            97% { filter: brightness(0.8); }
            98% { filter: brightness(1.2) hue-rotate(-10deg); }
        }
        @keyframes logo-ghost {
            0%, 90%, 100% { opacity: 0; transform: translateX(0); }
            92% { opacity: 0.5; transform: translateX(-3px); }
            94% { opacity: 0; transform: translateX(3px); }
            96% { opacity: 0.3; transform: translateX(-2px); }
        }
        /* Brand colors */
        :root {
            --gg-pink: #ff006e;
            --gg-purple: #8338ec;
            --gg-blue: #3a86ff;
            --gg-dark: #0a0a0a;
            --gg-gray: #222;
        }
        /* Seizure Safe Mode - active state */
        .seizure-safe-btn.active {
            background: #2ecc71 !important;
            border-color: #2ecc71 !important;
            color: #fff !important;
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.5);
        }
        /* SFW/NSFW Toggle - active states handled by JS inline styles */
        body.seizure-safe-mode .art-media img,
        body.seizure-safe-mode .art-media video {
            filter: contrast(0.85) saturate(0.7);
        }
        body.seizure-safe-mode .gallery-container::before {
            display: none; /* Remove scanlines */
        }
        body.seizure-safe-mode h1.logo {
            animation: none;
        }
        body.seizure-safe-mode h1.logo::before {
            animation: none;
            display: none;
        }
        @media (prefers-reduced-motion: reduce) {
            h1.logo, h1.logo::before {
                animation: none !important;
            }
        }
        /* Easter egg: Full site glitch effect */
        .site-glitch {
            animation: site-glitch-effect 0.5s ease-out;
        }
        @keyframes site-glitch-effect {
            0% { filter: none; transform: translate(0); }
            10% { filter: hue-rotate(90deg) saturate(2); transform: translate(-5px, 2px) skewX(2deg); }
            20% { filter: invert(1) hue-rotate(180deg); transform: translate(5px, -2px) skewX(-2deg); }
            30% { filter: hue-rotate(-90deg) contrast(2); transform: translate(-3px, 1px) skewX(1deg); }
            40% { filter: saturate(3) brightness(1.5); transform: translate(3px, -1px) skewX(-1deg); }
            50% { filter: hue-rotate(45deg) blur(2px); transform: translate(-2px, 2px); }
            60% { filter: invert(0.5) saturate(2); transform: translate(2px, -2px) skewX(1deg); }
            70% { filter: hue-rotate(-45deg) contrast(1.5); transform: translate(-1px, 1px); }
            80% { filter: saturate(1.5) brightness(1.2); transform: translate(1px, -1px); }
            90% { filter: hue-rotate(20deg); transform: translate(0); }
            100% { filter: none; transform: translate(0); }
        }
        /* Glitch overlay flash */
        .glitch-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
        }
        .glitch-overlay.active {
            animation: glitch-flash 0.5s ease-out;
        }
        @keyframes glitch-flash {
            0% { opacity: 0; background: transparent; }
            10% { opacity: 0.3; background: linear-gradient(90deg, #ff006e 0%, transparent 20%, #3a86ff 40%, transparent 60%, #8338ec 80%, transparent 100%); }
            20% { opacity: 0; }
            30% { opacity: 0.4; background: repeating-linear-gradient(0deg, transparent 0px, transparent 2px, rgba(255,0,110,0.3) 2px, rgba(255,0,110,0.3) 4px); }
            40% { opacity: 0; }
            50% { opacity: 0.2; background: #3a86ff; mix-blend-mode: overlay; }
            60% { opacity: 0; }
            70% { opacity: 0.1; background: linear-gradient(45deg, #ff006e, transparent, #8338ec); }
            100% { opacity: 0; }
        }
        /* RGB split on glitch */
        .rgb-split {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: screen;
            opacity: 0;
        }
        .rgb-split.active {
            animation: rgb-flash 0.3s ease-out;
        }
        @keyframes rgb-flash {
            0%, 100% { opacity: 0; }
            20% { opacity: 1; box-shadow: -5px 0 0 rgba(255,0,110,0.5), 5px 0 0 rgba(58,134,255,0.5); }
            40% { opacity: 1; box-shadow: 5px 0 0 rgba(255,0,110,0.5), -5px 0 0 rgba(58,134,255,0.5); }
            60% { opacity: 0.5; box-shadow: -3px 0 0 rgba(255,0,110,0.3), 3px 0 0 rgba(58,134,255,0.3); }
        }
        @keyframes glitch-text {
            0%, 90%, 100% { text-shadow: none; transform: translate(0); }
            91% { text-shadow: 2px 0 #ff006e, -2px 0 #3a86ff; transform: translate(-2px, 0); }
            92% { text-shadow: -2px 0 #ff006e, 2px 0 #3a86ff; transform: translate(2px, 0); }
            93% { text-shadow: none; transform: translate(0); }
        }
        /* Scanline overlay */
        .gallery-container::before {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,0.03) 0px,
                rgba(0,0,0,0.03) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 100;
        }
        .nav-btns { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        /* Unified nav pill base style */
        .nav-btn, .filter-toggle, .sfw-btn, .seizure-safe-btn {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.15);
            color: rgba(255,255,255,0.8);
            padding: 10px 18px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.8rem;
            font-weight: 500;
            letter-spacing: 0.5px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 25px;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
            white-space: nowrap;
        }
        .nav-btn::before, .filter-toggle::before, .sfw-btn::before, .seizure-safe-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255,0,110,0.15), rgba(131,56,236,0.15), rgba(58,134,255,0.15));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .nav-btn:hover::before, .filter-toggle:hover::before, .sfw-btn:hover::before, .seizure-safe-btn:hover::before {
            opacity: 1;
        }
        .nav-btn:hover, .filter-toggle:hover, .sfw-btn:hover, .seizure-safe-btn:hover {
            border-color: rgba(131,56,236,0.6);
            color: #fff;
            box-shadow: 0 0 20px rgba(131,56,236,0.4), 0 0 40px rgba(255,0,110,0.2);
            transform: translateY(-2px) scale(1.02);
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        .nav-btn.active {
            background: linear-gradient(135deg, rgba(255,0,110,0.2), rgba(131,56,236,0.3));
            border-color: rgba(131,56,236,0.6);
            color: #fff;
            box-shadow: 0 0 25px rgba(131,56,236,0.4), inset 0 0 15px rgba(255,0,110,0.1);
        }
        .saved-count {
            background: linear-gradient(135deg, #ff006e, #8338ec);
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            box-shadow: 0 0 10px rgba(255,0,110,0.5);
            margin-left: 5px;
        }
        .gallery-container {
            padding-top: 70px;
            min-height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
        }
        .scroll-track {
            display: flex;
            gap: 15px;
            padding: 15px;
            width: max-content;
            /* GPU acceleration for smooth scrolling */
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
        }
        .art-card {
            flex-shrink: 0;
            width: 300px;
            background: #111;
            border: 1px solid #222;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
            /* Performance optimizations */
            content-visibility: auto;
            contain-intrinsic-size: 300px 350px;
            will-change: transform;
        }
        .art-card:hover {
            border-color: #8338ec;
            transform: scale(1.03);
            animation: card-glitch 0.3s ease;
        }
        @keyframes card-glitch {
            0%, 100% { filter: none; }
            25% { filter: hue-rotate(90deg); }
            50% { filter: saturate(2) contrast(1.2); }
            75% { filter: hue-rotate(-90deg); }
        }
        .art-card:hover .art-media img {
            animation: rgb-split 0.5s ease;
        }
        @keyframes rgb-split {
            0%, 100% { filter: none; }
            20% { filter: drop-shadow(2px 0 0 rgba(255,0,110,0.5)) drop-shadow(-2px 0 0 rgba(58,134,255,0.5)); }
            40% { filter: drop-shadow(-1px 0 0 rgba(255,0,110,0.5)) drop-shadow(1px 0 0 rgba(58,134,255,0.5)); }
            60% { filter: none; }
        }
        /* Dopamine Rush mode styles - alternating rows */
        .gallery-container.dopamine-mode {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 65px 0 10px 0;
            height: 100vh;
            overflow: hidden;
        }
        .gallery-container.dopamine-mode .scroll-track {
            display: flex !important;
            flex-direction: column;
            gap: 6px;
            width: 100% !important;
        }
        .dopamine-row {
            display: flex;
            gap: 6px;
            width: max-content;
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
            height: 170px;
            flex-shrink: 0;
        }
        .dopamine-row .art-card {
            flex-shrink: 0;
            width: 200px !important;
            height: 165px !important;
            contain-intrinsic-size: 200px 165px;
        }
        .dopamine-row .art-media {
            height: 130px !important;
        }
        .dopamine-row .art-info {
            padding: 4px 6px;
            font-size: 0.55rem;
            height: 30px;
            overflow: hidden;
        }
        .dopamine-row .art-info h3 {
            font-size: 0.6rem;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .dopamine-row .save-btn {
            padding: 3px 6px;
            font-size: 0.5rem;
        }
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            header {
                padding: 10px 15px;
                flex-wrap: wrap;
                gap: 10px;
            }
            h1 { font-size: 1.2rem; }
            .nav-btns {
                gap: 8px;
                flex-wrap: wrap;
            }
            .nav-btn, .filter-toggle, .sfw-btn, .seizure-safe-btn {
                padding: 6px 12px;
                font-size: 0.75rem;
            }
            .filter-panel {
                top: auto;
                max-height: 70vh;
                padding: 15px;
            }
            .filter-tag, .preset-btn {
                padding: 8px 12px;
                font-size: 0.75rem;
            }
            .art-card { width: 250px; }
            .art-media { height: 250px; }
            .gallery-container { padding-top: 100px; }
            .dopamine-row { height: 140px; }
            .dopamine-row .art-card { width: 150px !important; height: 135px !important; }
            .dopamine-row .art-media { height: 105px !important; }
            .fullscreen-modal img {
                max-width: 95vw;
                max-height: 60vh;
            }
            .source-control {
                padding: 8px;
            }
            .custom-filter-input {
                width: 150px;
            }
        }
        @media (max-width: 480px) {
            h1 { font-size: 1rem; }
            .art-card { width: 200px; }
            .art-media { height: 200px; }
            .dopamine-row { height: 120px; }
            .dopamine-row .art-card { width: 120px !important; height: 115px !important; }
            .dopamine-row .art-media { height: 85px !important; }
            .filter-section h4 { font-size: 0.75rem; }
        }
        .art-media {
            width: 100%;
            height: 300px;
            background: #000;
            overflow: hidden;
        }
        .art-media img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* Smooth image rendering */
            image-rendering: auto;
            transform: translateZ(0);
        }
        /* NFT Price badge */
        .price-badge {
            position: absolute;
            bottom: 8px;
            right: 8px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            backdrop-filter: blur(8px);
            z-index: 5;
        }
        .price-badge.available {
            background: linear-gradient(135deg, rgba(0,200,100,0.8), rgba(0,150,80,0.9));
            color: #fff;
            box-shadow: 0 2px 8px rgba(0,200,100,0.3);
        }
        .price-badge.sold-out {
            background: rgba(100,100,100,0.8);
            color: #aaa;
        }
        .price-badge.one-of-one {
            border: 1px solid gold;
        }
        .price-badge .edition-info {
            display: block;
            font-size: 0.6rem;
            font-weight: normal;
            opacity: 0.9;
            margin-top: 2px;
        }
        .bookmark-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.6);
            border: none;
            color: #fff;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1rem;
            z-index: 10;
        }
        .bookmark-btn:hover, .bookmark-btn.saved { background: #ff006e; }
        .art-info {
            padding: 10px;
            font-size: 0.75rem;
            color: #888;
        }
        .saved-section {
            display: none;
            padding: 90px 20px 20px;
        }
        .saved-section.active { display: block; }
        .gallery-container.hidden { display: none; }
        .saved-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }
        .saved-card {
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
        }
        .saved-card .art-media { height: 200px; }
        .tag-input {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            padding: 6px 10px;
            font-size: 0.8rem;
            margin-top: 8px;
        }
        .remove-btn {
            background: #ff006e;
            border: none;
            color: #fff;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 0.75rem;
            margin-top: 8px;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: #111;
            padding: 20px;
            border-radius: 12px;
            max-width: 400px;
            width: 90%;
        }
        .modal-content h3 { margin-bottom: 15px; }
        .modal-input {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #fff;
            padding: 10px;
            margin-bottom: 10px;
        }
        .modal-btns { display: flex; gap: 10px; justify-content: flex-end; }
        .modal-btn { padding: 8px 16px; border: none; cursor: pointer; }
        .modal-btn.save { background: #8338ec; color: #fff; }
        .modal-btn.cancel { background: #333; color: #fff; }
        .fullscreen-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 3000;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            cursor: pointer;
            overflow-y: auto;
            padding: 40px 20px;
        }
        .fullscreen-modal.active { display: flex; }
        .fullscreen-modal img {
            max-width: 90vw;
            max-height: 60vh;
            object-fit: contain;
            flex-shrink: 0;
        }
        .fullscreen-info {
            margin-top: 20px;
            text-align: center;
            max-width: 80vw;
            flex-shrink: 0;
        }
        .fullscreen-title {
            color: #fff;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        .fullscreen-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
        }
        .fullscreen-tag {
            background: #222;
            border: 1px solid #444;
            color: #aaa;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .fullscreen-tag:hover {
            background: #8338ec;
            border-color: #8338ec;
            color: #fff;
        }
        .fullscreen-artist {
            color: #888;
            font-size: 0.8rem;
            margin-bottom: 12px;
        }
        .fullscreen-save-btn {
            margin-top: 15px;
            background: #8338ec;
            border: none;
            color: #fff;
            padding: 10px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        .fullscreen-save-btn:hover {
            transform: scale(1.05);
        }
        .fullscreen-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .fullscreen-price {
            background: linear-gradient(135deg, rgba(0,200,100,0.2), rgba(0,150,80,0.3));
            border: 1px solid rgba(0,200,100,0.5);
            color: #00c864;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            margin-bottom: 12px;
        }
        .fullscreen-price.sold-out {
            background: rgba(100,100,100,0.2);
            border-color: rgba(100,100,100,0.5);
            color: #888;
        }
        .fullscreen-external-btn {
            background: linear-gradient(135deg, #3a86ff, #8338ec);
            border: none;
            color: #fff;
            padding: 10px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 0.9rem;
            text-decoration: none;
            transition: all 0.2s;
            display: inline-block;
        }
        .fullscreen-external-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(58,134,255,0.4);
        }
        /* Epic Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }
        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }
        .loading-screen::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0,0,0,0) 0px,
                rgba(0,0,0,0) 1px,
                rgba(0,255,255,0.03) 1px,
                rgba(0,255,255,0.03) 2px
            );
            pointer-events: none;
            animation: scanline-move 8s linear infinite;
        }
        @keyframes scanline-move {
            0% { transform: translateY(0); }
            100% { transform: translateY(100px); }
        }
        .loading-text {
            font-size: 8rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: -8px;
            position: relative;
            background: linear-gradient(135deg, #ff006e 0%, #8338ec 50%, #3a86ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: main-glitch 3s infinite;
            text-shadow: 0 0 80px rgba(131, 56, 236, 0.5);
        }
        .loading-text::before,
        .loading-text::after {
            content: 'GG';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            -webkit-text-fill-color: initial;
        }
        .loading-text::before {
            color: #ff006e;
            animation: glitch-1 2s infinite;
            clip-path: polygon(0 0, 100% 0, 100% 35%, 0 35%);
            text-shadow: -4px 0 #ff006e;
        }
        .loading-text::after {
            color: #3a86ff;
            animation: glitch-2 2s infinite;
            clip-path: polygon(0 65%, 100% 65%, 100% 100%, 0 100%);
            text-shadow: 4px 0 #3a86ff;
        }
        @keyframes main-glitch {
            0%, 90%, 100% { transform: translate(0); }
            91% { transform: translate(-5px, 2px); }
            92% { transform: translate(5px, -2px); }
            93% { transform: translate(-3px, 1px); }
            94% { transform: translate(3px, -1px); }
        }
        @keyframes glitch-1 {
            0%, 85%, 100% { transform: translate(0); opacity: 0.8; }
            86% { transform: translate(10px, 0); }
            87% { transform: translate(-10px, 0); }
            88% { transform: translate(5px, 0); }
            89% { transform: translate(-5px, 0); opacity: 0; }
            90% { opacity: 0.8; }
        }
        @keyframes glitch-2 {
            0%, 85%, 100% { transform: translate(0); opacity: 0.8; }
            86% { transform: translate(-10px, 0); }
            87% { transform: translate(10px, 0); }
            88% { transform: translate(-5px, 0); }
            89% { transform: translate(5px, 0); opacity: 0; }
            90% { opacity: 0.8; }
        }
        .loading-subtitle {
            margin-top: 20px;
            font-size: 1rem;
            color: #8338ec;
            letter-spacing: 4px;
            animation: pulse-text 1.5s ease-in-out infinite;
        }
        @keyframes pulse-text {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        .loading-bars {
            display: flex;
            gap: 8px;
            margin-top: 40px;
        }
        .loading-bar {
            width: 8px;
            height: 50px;
            background: linear-gradient(180deg, #ff006e, #8338ec, #3a86ff);
            animation: bar-dance 1s ease-in-out infinite;
        }
        .loading-bar:nth-child(1) { animation-delay: 0s; }
        .loading-bar:nth-child(2) { animation-delay: 0.1s; }
        .loading-bar:nth-child(3) { animation-delay: 0.2s; }
        .loading-bar:nth-child(4) { animation-delay: 0.3s; }
        .loading-bar:nth-child(5) { animation-delay: 0.4s; }
        .loading-bar:nth-child(6) { animation-delay: 0.5s; }
        .loading-bar:nth-child(7) { animation-delay: 0.6s; }
        @keyframes bar-dance {
            0%, 100% { transform: scaleY(0.3); opacity: 0.5; }
            50% { transform: scaleY(1); opacity: 1; }
        }
        .loading-progress {
            margin-top: 30px;
            width: 300px;
            height: 4px;
            background: #222;
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff006e, #8338ec, #3a86ff, #ff006e);
            background-size: 300% 100%;
            animation: progress-flow 2s linear infinite, progress-width 3s ease-out forwards;
            width: 0%;
        }
        @keyframes progress-flow {
            0% { background-position: 100% 0; }
            100% { background-position: 0% 0; }
        }
        @keyframes progress-width {
            0% { width: 0%; }
            50% { width: 70%; }
            100% { width: 95%; }
        }
        .loading-status {
            margin-top: 15px;
            font-size: 0.75rem;
            color: #444;
            letter-spacing: 2px;
            animation: status-flicker 0.5s infinite;
        }
        @keyframes status-flicker {
            0%, 90%, 100% { opacity: 1; }
            95% { opacity: 0.5; }
        }
        /* Corner decorations */
        .loading-corner {
            position: absolute;
            width: 50px;
            height: 50px;
            border: 2px solid #8338ec;
        }
        .loading-corner.tl { top: 30px; left: 30px; border-right: none; border-bottom: none; }
        .loading-corner.tr { top: 30px; right: 30px; border-left: none; border-bottom: none; }
        .loading-corner.bl { bottom: 30px; left: 30px; border-right: none; border-top: none; }
        .loading-corner.br { bottom: 30px; right: 30px; border-left: none; border-top: none; }
        .loading-corner::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ff006e;
            animation: corner-pulse 2s infinite;
        }
        .tl::after { top: -2px; left: -2px; }
        .tr::after { top: -2px; right: -2px; }
        .bl::after { bottom: -2px; left: -2px; }
        .br::after { bottom: -2px; right: -2px; }
        @keyframes corner-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }
        /* Old simple loading fallback */
        .loading {
            color: #666;
            text-align: center;
            padding: 40px;
        }
        /* Random flicker effect on body */
        @keyframes screen-flicker {
            0%, 97%, 100% { opacity: 1; }
            97.5% { opacity: 0.97; }
            98% { opacity: 1; }
            98.5% { opacity: 0.98; }
        }
        body { animation: screen-flicker 8s infinite; }

        /* Matrix Rain Easter Egg Effect */
        .matrix-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 99999;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.9);
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .matrix-container.active {
            opacity: 1;
        }
        .matrix-container.fade-out {
            opacity: 0;
        }
        .matrix-canvas {
            width: 100%;
            height: 100%;
        }
        .matrix-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00;
            text-align: center;
            opacity: 0;
            animation: matrix-reveal 1s ease forwards 2s;
        }
        @keyframes matrix-reveal {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        /* Easter egg filter styling - subtle */
        .easter-egg-filter {
            opacity: 0.3;
            font-size: 0.6rem !important;
            transition: all 0.3s ease;
        }
        .easter-egg-filter:hover {
            opacity: 1;
            color: #00ff00 !important;
            border-color: #00ff00 !important;
            text-shadow: 0 0 5px #00ff00;
        }
        .secret-reveal {
            animation: secret-glow 0.5s ease;
        }
        @keyframes secret-glow {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Filter toggle active state */
        .filter-toggle.active {
            background: linear-gradient(135deg, rgba(255,0,110,0.15), rgba(131,56,236,0.25));
            border-color: rgba(131,56,236,0.5);
            color: #fff;
            box-shadow: 0 0 20px rgba(131,56,236,0.3);
        }
        .filter-panel {
            display: none;
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            background: rgba(10,10,10,0.98);
            border-bottom: 1px solid #333;
            padding: 20px;
            z-index: 999;
            max-height: 60vh;
            overflow-y: auto;
        }
        .filter-panel.active { display: block; }
        .filter-section { margin-bottom: 20px; }
        .filter-section h4 { color: #888; margin-bottom: 10px; font-size: 0.85rem; }
        .filter-tags { display: flex; flex-wrap: wrap; gap: 8px; }
        .filter-tag {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.6);
            padding: 6px 14px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(8px);
        }
        .filter-tag:hover {
            border-color: rgba(131,56,236,0.4);
            color: rgba(255,255,255,0.9);
            box-shadow: 0 0 12px rgba(131,56,236,0.2);
        }
        .filter-tag.active {
            background: linear-gradient(135deg, rgba(255,0,110,0.3), rgba(131,56,236,0.4));
            border-color: rgba(131,56,236,0.6);
            color: #fff;
            box-shadow: 0 0 15px rgba(131,56,236,0.35);
        }
        .filter-tag.coming-soon {
            background: rgba(50,50,50,0.5);
            border-color: rgba(100,100,100,0.3);
            color: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .filter-tag.coming-soon:hover {
            transform: none;
            box-shadow: none;
        }
        .filter-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            padding: 15px;
            background: linear-gradient(180deg, transparent 0%, rgba(0,0,0,0.95) 20%, rgba(0,0,0,0.98) 100%);
            border-top: 1px solid #333;
            position: sticky;
            bottom: 0;
            margin: 0 -15px -15px -15px;
            z-index: 10;
        }
        .custom-filter-input {
            background: #1a1a1a;
            border: 1px solid #444;
            color: #fff;
            padding: 8px 12px;
            font-size: 0.85rem;
            width: 200px;
        }
        .apply-btn {
            background: linear-gradient(135deg, rgba(255,0,110,0.4), rgba(131,56,236,0.5));
            border: 1px solid rgba(131,56,236,0.4);
            color: #fff;
            padding: 8px 24px;
            cursor: pointer;
            font-family: inherit;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(131,56,236,0.2);
        }
        .apply-btn:hover {
            background: linear-gradient(135deg, rgba(255,0,110,0.5), rgba(131,56,236,0.6));
            box-shadow: 0 0 25px rgba(131,56,236,0.4);
            transform: translateY(-2px);
        }
        .preset-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.7);
            padding: 6px 14px;
            cursor: pointer;
            font-size: 0.75rem;
            border-radius: 15px;
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
        }
        .preset-btn:hover {
            background: rgba(255,255,255,0.08);
            border-color: rgba(131,56,236,0.4);
            color: #fff;
            box-shadow: 0 0 12px rgba(131,56,236,0.2);
        }
        .source-control {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #1a1a1a;
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #333;
        }
        .source-control.disabled { opacity: 0.4; }
        .source-name {
            cursor: pointer;
            font-size: 0.75rem;
            min-width: 70px;
            color: #fff;
        }
        .source-name.off { color: #666; text-decoration: line-through; }
        .source-weight {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 2px;
            cursor: pointer;
        }
        .source-weight::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #8338ec;
            border-radius: 50%;
            cursor: pointer;
        }
        .weight-val { font-size: 0.65rem; color: #888; width: 25px; text-align: right; }
    </style>
</head>
<body>
    <!-- Glitch Easter Egg Overlays -->
    <div class="glitch-overlay" id="glitchOverlay"></div>
    <div class="rgb-split" id="rgbSplit"></div>

    <!-- Epic Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-corner tl"></div>
        <div class="loading-corner tr"></div>
        <div class="loading-corner bl"></div>
        <div class="loading-corner br"></div>
        <div class="loading-text">GG</div>
        <div class="loading-subtitle">GLITCH GALLERY</div>
        <div class="loading-bars">
            <div class="loading-bar"></div>
            <div class="loading-bar"></div>
            <div class="loading-bar"></div>
            <div class="loading-bar"></div>
            <div class="loading-bar"></div>
            <div class="loading-bar"></div>
            <div class="loading-bar"></div>
        </div>
        <div class="loading-progress">
            <div class="loading-progress-bar"></div>
        </div>
        <div class="loading-status" id="loadingStatus">INITIALIZING FEEDS...</div>
    </div>

    <!-- Matrix Easter Egg Container -->
    <div class="matrix-container" id="matrixContainer">
        <canvas class="matrix-canvas" id="matrixCanvas"></canvas>
        <div class="matrix-message" id="matrixMessage">YOU FOUND THE SECRET<br><span style="font-size:1.5rem;">ðŸ¥š Easter Egg Hunter ðŸ¥š</span></div>
    </div>

    <header>
        <h1 class="logo">GG <span class="logo-text">GLITCH GALLERY</span></h1>
        <div class="nav-btns">
            <button class="nav-btn active" onclick="showGallery()">Gallery</button>
            <button class="nav-btn" onclick="showSaved()">Saved <span class="saved-count" id="savedCount">0</span></button>
            <button class="filter-toggle" onclick="toggleFilters()">Filters</button>
            <button class="filter-toggle" onclick="toggleSettings()">Settings</button>
            <button class="sfw-btn sfw-active" id="sfwBtn" onclick="toggleSfwMode()" title="Toggle Safe For Work / NSFW content">SFW</button>
            <button class="seizure-safe-btn" id="seizureSafeBtn" onclick="toggleSeizureSafe()" title="Reduces flashing, shows static images, filters strobe content">Seizure Safe</button>
        </div>
    </header>

    <div class="filter-panel" id="filterPanel">
        <div class="filter-section">
            <h4>SOURCES
                <button class="preset-btn" style="margin-left:15px;" onclick="allSourcesOn()">All On</button>
                <button class="preset-btn" onclick="allSourcesOff()">All Off</button>
                <button class="preset-btn" style="background:#8338ec;" onclick="objktOnly()">OBJKT Only</button>
            </h4>
            <div class="filter-tags" id="sourceToggles"></div>
        </div>
        <div class="filter-section">
            <h4>OBJKT ARTIST (search by Tezos wallet or alias - leave blank for all)</h4>
            <div style="display:flex;gap:10px;align-items:center;">
                <input type="text" class="custom-filter-input" id="objktArtistInput" placeholder="e.g. tz1... or artist alias (Enter to apply)" style="width:300px;" onkeydown="if(event.key==='Enter'){event.preventDefault();setObjktArtist();}">
                <button class="preset-btn" onclick="setObjktArtist()">Apply</button>
                <button class="preset-btn" onclick="clearObjktArtist()">Clear</button>
                <span id="objktArtistStatus" style="color:#8338ec;font-size:0.75rem;"></span>
            </div>
        </div>
        <div class="filter-section">
            <h4>ART WHEEL - Quick Presets <span id="activePresetIndicator" style="color:#2ecc71;font-size:0.8rem;"></span></h4>
            <div class="filter-tags" id="artWheelContainer" style="display:flex;flex-wrap:wrap;gap:8px;"></div>
        </div>
        <div class="filter-section">
            <h4>MY SAVED PRESETS
                <button class="preset-btn" style="margin-left:15px;background:#3a86ff;" onclick="saveCurrentPreset()">+ Save Current</button>
            </h4>
            <div class="filter-tags" id="savedPresetsContainer">
                <span style="color:#666;font-size:0.8rem;">No saved presets yet</span>
            </div>
        </div>
        <div class="filter-section">
            <h4>ACTIVE FILTERS <span id="activeFilterCount" style="color:#ff006e;font-size:0.8rem;"></span>
                <button class="preset-btn" style="margin-left:10px;background:#333;font-size:0.7rem;padding:4px 8px;" onclick="searchTerms=[];renderFilterTags();updatePendingChangesIndicator();">Clear All</button>
            </h4>
            <div class="filter-tags" id="activeFilters" style="margin-bottom:10px;min-height:30px;">
                <span style="color:#666;font-size:0.8rem;">No filters - showing all art</span>
            </div>
        </div>
        <div class="filter-section">
            <h4>FINE-TUNE FILTERS (click to expand categories)</h4>
            <div id="filterCategories"></div>
        </div>
        <div class="filter-section">
            <h4>ARTISTS (click to search for specific artists)
                <button class="preset-btn" style="margin-left:15px;" onclick="allArtistsOn()">All On</button>
                <button class="preset-btn" onclick="allArtistsOff()">All Off</button>
            </h4>
            <div class="filter-tags" id="artistTags"></div>
        </div>
        <div class="filter-section">
            <h4>REDDIT SUBREDDITS (always included when Reddit source is on)
                <button class="preset-btn" style="margin-left:15px;" onclick="allSubredditsOn()">All On</button>
                <button class="preset-btn" onclick="allSubredditsOff()">All Off</button>
            </h4>
            <div class="filter-tags" id="redditTags"></div>
            <div style="margin-top:10px;display:flex;gap:10px;align-items:center;">
                <input type="text" class="custom-filter-input" id="customSubreddit" placeholder="Add subreddit (e.g. glitchart)" style="width:200px;">
                <button class="preset-btn" onclick="addCustomSubreddit()">Add Subreddit</button>
            </div>
        </div>
        <div class="filter-actions">
            <input type="text" class="custom-filter-input" id="customFilter" placeholder="Add custom filter...">
            <button class="preset-btn" onclick="addCustomFilter()">Add</button>
            <button class="preset-btn" style="background:#8338ec;" onclick="clearAllFilters()">Random Art</button>
            <button class="apply-btn" style="background:#ff006e;font-size:1rem;padding:12px 25px;" onclick="applyFilters()">APPLY CHANGES</button>
            <span style="color:#ff006e; font-size:0.85rem; display:none;" id="pendingChanges">âš  Changes pending</span>
            <span style="color:#666; font-size:0.75rem;" id="filterCount"></span>
        </div>
    </div>

    <div class="filter-panel" id="settingsPanel">
        <div class="filter-section">
            <h4>SOURCE WEIGHTS (adjust how much content from each source)</h4>
            <div id="sourceControls" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:8px;"></div>
        </div>
        <div class="filter-section">
            <h4>DISPLAY SETTINGS</h4>
            <div style="display:flex;flex-wrap:wrap;gap:30px;align-items:flex-start;">
                <div>
                    <span style="color:#888;font-size:0.8rem;">Scroll Speed</span>
                    <div style="display:flex;align-items:center;gap:10px;margin-top:5px;">
                        <input type="range" class="source-weight" style="width:150px;" min="0.5" max="8" step="0.5" value="2" oninput="updateScrollSpeed(this.value)" id="scrollSpeedSlider">
                        <span id="scrollSpeedVal" style="min-width:30px;">2x</span>
                    </div>
                </div>
                <div>
                    <span style="color:#888;font-size:0.8rem;">Image Size</span>
                    <div style="display:flex;align-items:center;gap:10px;margin-top:5px;">
                        <input type="range" class="source-weight" style="width:150px;" min="150" max="500" step="25" value="300" oninput="updateCardSize(this.value)" id="cardSizeSlider">
                        <span id="cardSizeVal" style="min-width:45px;">300px</span>
                    </div>
                </div>
                <div>
                    <span style="color:#888;font-size:0.8rem;">Layout Mode</span>
                    <div style="display:flex;align-items:center;gap:10px;margin-top:5px;">
                        <button class="preset-btn" id="dopamineBtn" onclick="toggleDopamineMode()" style="background:#333;">
                            DOPAMINE RUSH
                        </button>
                        <span style="color:#666;font-size:0.7rem;">3 rows, chaotic scrolling</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="gallery-container" id="galleryContainer">
        <div class="scroll-track" id="scrollTrack">
            <div class="loading">Loading glitch art...</div>
        </div>
    </div>

    <div class="saved-section" id="savedSection">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
            <h2>Saved</h2>
            <div style="display:flex;gap:10px;">
                <button class="preset-btn" onclick="exportCollection()">Export JSON</button>
                <label class="preset-btn" style="cursor:pointer;">
                    Import JSON
                    <input type="file" accept=".json" onchange="importCollection(event)" style="display:none;">
                </label>
            </div>
        </div>
        <div class="saved-grid" id="savedGrid"></div>
    </div>

    <div class="modal" id="saveModal">
        <div class="modal-content">
            <h3>Save</h3>
            <input type="text" class="modal-input" id="tagInput" placeholder="Tags (e.g., favorite, dark, trippy)">
            <input type="text" class="modal-input" id="noteInput" placeholder="Note...">
            <div class="modal-btns">
                <button class="modal-btn cancel" onclick="closeModal()">Cancel</button>
                <button class="modal-btn save" onclick="confirmSave()">Save</button>
            </div>
        </div>
    </div>

    <div class="fullscreen-modal" id="fullscreenModal" onclick="closeFullscreen()">
        <img id="fullscreenImg" src="">
        <div class="fullscreen-info" onclick="event.stopPropagation()">
            <div class="fullscreen-title" id="fullscreenTitle"></div>
            <div class="fullscreen-artist" id="fullscreenArtist"></div>
            <div class="fullscreen-price" id="fullscreenPrice" style="display:none;"></div>
            <div class="fullscreen-tags" id="fullscreenTags"></div>
            <div class="fullscreen-actions">
                <button class="fullscreen-save-btn" id="fullscreenSaveBtn" onclick="saveFromFullscreen()">â˜† Save to Collection</button>
                <a class="fullscreen-external-btn" id="fullscreenExternalBtn" href="#" target="_blank" onclick="event.stopPropagation();" style="display:none;">â†— View on objkt.com</a>
            </div>
        </div>
    </div>

    <script>
        // Performance constants
        const MAX_GIFS = 1000; // Cap to prevent memory bloat
        const gifIdSet = new Set(); // Fast deduplication lookup

        let allGifs = [];
        let savedArtworks = JSON.parse(localStorage.getItem('savedGlitchArt')) || [];
        let currentArtwork = null;
        let scrollPos = 0;
        let mouseControlled = false;
        let mouseSpeed = 0;
        let autoSpeed = -2;
        let cardSize = 300; // default card width
        let dopamineMode = false;

        // Easter egg hunt state
        let easterEggState = {
            eggFound: false,      // Step 1: Easter Egg filter clicked
            secretSubFound: false, // Step 2: notasecret subreddit clicked
            shhhFound: false       // Step 3: shhhh source clicked
        };
        let rowScrollPos = []; // for dopamine mode horizontal rows
        let dopamineRefreshInterval = null; // auto-refresh timer for dopamine mode

        // API Keys
        const TENOR_KEY = 'AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ'; // Tenor public key
        const GIPHY_KEY = 'Gc7131jiJuvI7IdN0HZ1D7nh0ow5BU6g'; // Giphy API key
        const PEXELS_KEY = '563492ad6f917000010000012a4c39e704c640ad9eb24ebd49377f72'; // Pexels API key
        const PIXABAY_KEY = '47566592-de5ebf9f52361e96516673498'; // Pixabay API key
        const NASA_KEY = 'DEMO_KEY'; // NASA public demo key (rate limited but works)

        // Source toggles (exchange, mallow, foster, pixabay disabled - no public API or needs user key)
        let sourcesEnabled = { tenor: true, reddit: true, giphy: true, objkt: true, pexels: true, pixabay: false, nasa: true, exchange: false, mallow: false, foster: false, deviantart: true, tumblr: true, bluesky: true, archive: true, wikipedia: true };

        // Source weights (1 = normal, 2 = double, 0.5 = half, etc.)
        let sourceWeights = { tenor: 1, reddit: 1, giphy: 1, objkt: 1, pexels: 1, pixabay: 1, nasa: 1, exchange: 1, mallow: 1, foster: 1, deviantart: 1, tumblr: 1, bluesky: 1, archive: 1, wikipedia: 1 };

        // Animation cache (for dopamine mode performance)
        let animCachedTrack = null;
        let animCachedRows = [];
        let animLastRowCount = 0;

        // Seizure Safe Mode
        let seizureSafeMode = localStorage.getItem('seizureSafeMode') === 'true' || window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const FLASH_TAGS = ['strobe', 'flashing', 'flash', 'epilepsy', 'seizure', 'warning', 'photosensitive', 'blink', 'rapid', 'strobe light'];

        // SFW/NSFW Mode (SFW by default)
        let sfwMode = localStorage.getItem('sfwMode') !== 'false'; // Default true (SFW)
        const NSFW_TAGS = ['nsfw', 'nude', 'nudity', 'porn', 'xxx', 'adult', 'explicit', 'sexy', 'erotic', 'hentai', 'rule34', 'lewd', 'naked', 'sex', 'boobs', 'ass', 'dick', 'pussy', 'fetish', 'kink', 'bondage', 'bdsm'];

        // Deduplication tracking
        const seenUrls = new Set(); // Track URLs to prevent duplicate images
        const artistCountMap = new Map(); // Track how many items per artist

        // Helper to add gif only if URL not seen before
        function addGifIfUnique(gif) {
            const url = gif.images?.fixed_height?.url || gif.images?.original?.url;
            if (!url || seenUrls.has(url)) return false;
            seenUrls.add(url);
            // Also add to gifIdSet for dopamine mode dedup
            const baseId = gif.id?.split('_').slice(0, 2).join('_');
            if (baseId) gifIdSet.add(baseId);
            allGifs.push(gif);
            return true;
        }

        // Clear all deduplication caches (call when resetting gallery)
        function clearDedupCaches() {
            seenUrls.clear();
            gifIdSet.clear();
        }

        // objkt.com artist handle filter (e.g., "tz1abc..." or artist alias)
        let objktArtistHandle = '';

        // Famous glitch/digital artists
        const allArtists = [
            'Rosa Menkman', 'Sabato Visconti', 'Kim Asendorf', 'Daniel Temkin',
            'Antonio Roberts', 'Nick Briz', 'Jon Satrom', 'Evan Meaney',
            'Phillip Stearns', 'glitchaus', 'Sarah Zucker', 'XCOPY',
            'Beeple', 'Mad Dog Jones', 'Coldie', 'Hackatao', 'Pak',
            'Kevin Abosch', 'Trevor Jones', 'Dmitri Cherniak', 'Tyler Hobbs',
            'Casey REAS', 'RafaÃ«l Rozendaal', 'Jennifer Juniper Stratford',
            'Kate the Cursed', 'TACHYONS+', 'Max Osiris', 'Neurocolor'
        ];
        let selectedArtists = [];

        // Reddit subreddits for art (no API key needed)
        const allRedditSubs = [
            // Glitch & experimental
            'glitch_art', 'VaporwaveAesthetics', 'currentlytripping', 'woahdude', 'trippy',
            'loadingicon', 'perfectloops', 'pixelsorting', 'brokengifs', 'gonwild',
            // Digital art
            'Art', 'DigitalArt', 'ImaginaryLandscapes', 'ImaginaryCharacters', 'Cyberpunk',
            'outrun', 'PixelArt', 'generative', 'PlotterArt', 'proceduralgeneration',
            // Traditional & mixed
            'AbstractArt', 'ContemporaryArt', 'museum', 'ArtPorn', 'Illustration',
            // Animation & motion
            'animation', 'HighQualityGifs', 'Cinemagraphs', 'SplitDepthGIFS',
            // Photography & visual
            'ExposurePorn', 'LongExposurePics', 'itookapicture', 'photocritique'
        ];
        let redditSubs = []; // Off by default - presets can enable specific subreddits

        // Organized filter categories
        const filterCategories = {
            glitch: {
                name: 'Glitch & Experimental',
                color: '#ff006e',
                terms: ['glitch art', 'datamosh', 'vhs glitch', 'digital glitch', 'pixel glitch', 'video glitch', 'glitch aesthetic', 'corrupted', 'distortion art', 'rgb split', 'scan lines', 'broken tv', 'signal noise', 'pixel sort', 'data corruption', 'static noise', 'analog glitch']
            },
            traditional: {
                name: 'Traditional Art',
                color: '#8b4513',
                terms: ['watercolor', 'oil painting', 'acrylic', 'impressionism', 'portrait', 'landscape', 'sketch', 'charcoal', 'pastel', 'sculpture', 'pen and ink', 'gouache', 'tempera', 'fresco', 'still life']
            },
            digital: {
                name: 'Digital Art',
                color: '#3a86ff',
                terms: ['digital art', 'digital painting', 'concept art', 'fantasy art', 'character design', 'illustration', 'vector art', 'matte painting', 'fan art', 'comic art', 'manga']
            },
            pixel: {
                name: 'Pixel Art & Retro',
                color: '#00ff88',
                terms: ['pixel art', '8bit', '16bit', 'retro gaming', 'sprite art', 'pixel animation', 'chiptune', 'gameboy', 'nes', 'snes', 'retro', 'arcade']
            },
            animation: {
                name: 'Animation & Motion',
                color: '#ff8c00',
                terms: ['animation', 'motion graphics', 'loop', 'animated', '2d animation', '3d animation', 'stop motion', 'rotoscope', 'anime', 'cartoon', 'motion design', 'kinetic typography']
            },
            threeD: {
                name: '3D & Blender',
                color: '#ff6b6b',
                terms: ['3d art', '3d render', 'cgi', 'blender', 'octane', 'cinema4d', 'maya', 'zbrush', 'sculpting', 'lowpoly', 'isometric', 'voxel', '3d modeling', 'environment design']
            },
            ai: {
                name: 'AI Generated',
                color: '#9b59b6',
                terms: ['ai art', 'ai generated', 'midjourney', 'stable diffusion', 'dall-e', 'generative ai', 'neural art', 'machine learning art', 'deepdream', 'gan art']
            },
            nft: {
                name: 'NFT & Crypto Art',
                color: '#8338ec',
                terms: ['nft art', 'crypto art', 'generative art', 'pfp', 'collectible', '1/1', 'edition', 'on-chain', 'tezos art', 'ethereum art']
            },
            photography: {
                name: 'Photography',
                color: '#2ecc71',
                terms: ['photography', 'long exposure', 'macro', 'cinematic', 'moody', 'portrait photography', 'street photography', 'landscape photography', 'nature photography', 'black and white']
            },
            aesthetic: {
                name: 'Aesthetic Styles',
                color: '#e91e63',
                terms: ['vaporwave', 'synthwave', 'cyberpunk', 'neon', 'aesthetic', 'dark art', 'gothic', 'surrealism', 'minimalist', 'maximalist', 'brutalist', 'y2k', 'cottagecore', 'liminal space']
            },
            abstract: {
                name: 'Abstract & Generative',
                color: '#00bcd4',
                terms: ['abstract art', 'generative art', 'geometric', 'pattern', 'fractal', 'op art', 'constructivism', 'algorithmic art', 'procedural', 'code art']
            },
            webNostalgia: {
                name: 'Internet Nostalgia',
                color: '#00ff00',
                terms: ['90s website', 'geocities', 'old internet', 'web design', 'y2k aesthetic', 'retro internet', 'vintage web', 'old web', 'website screenshot', 'early internet', 'netscape', 'web 1.0', 'internet aesthetic', 'cyber y2k', 'windows 95', 'windows 98', 'ms paint', 'pixel cursor', 'under construction gif']
            },
            anime: {
                name: 'Anime & Manga',
                color: '#ff69b4',
                terms: ['anime', 'manga', 'anime art', 'anime aesthetic', 'studio ghibli', 'anime girl', 'anime boy', 'anime scenery', 'anime wallpaper', 'kawaii', 'chibi', 'otaku', 'weeb', 'anime gif', 'sakura', 'mecha', 'shonen', 'seinen', 'slice of life anime', 'anime landscape', 'lofi anime', 'anime vibes']
            },
            nostalgia: {
                name: 'Nostalgia & Retro',
                color: '#daa520',
                terms: ['nostalgia', 'retro', 'vintage', '80s', '90s', '2000s', 'throwback', 'old school', 'retro aesthetic', 'vintage aesthetic', 'childhood', 'memories', 'classic', 'antique', 'film grain', 'polaroid', 'vhs aesthetic', 'cassette', 'floppy disk', 'crt monitor', 'old tv', 'arcade', 'vintage gaming', 'blockbuster']
            }
        };

        // Flatten all terms for allSearchTerms
        const allSearchTerms = Object.values(filterCategories).flatMap(cat => cat.terms);

        // Glitch-specific terms (for glitch preset)
        const glitchTerms = filterCategories.glitch.terms;

        // Presets (quick access buttons)
        const presets = {
            glitch: glitchTerms,
            pixel: filterCategories.pixel.terms,
            painting: filterCategories.traditional.terms.slice(0, 6),
            animation: filterCategories.animation.terms.slice(0, 6),
            '3d': filterCategories.threeD.terms.slice(0, 6),
            abstract: filterCategories.abstract.terms.slice(0, 5),
            dark: ['dark art', 'gothic', 'horror art', 'macabre', 'surreal dark'],
            vhs: ['vhs glitch', 'retro glitch', 'analog glitch', 'scan lines', 'broken tv', 'signal noise', 'static noise'],
            cyber: ['cyberpunk', 'neon', 'synthwave', 'vaporwave', 'holographic', 'futuristic'],
            trippy: ['trippy visuals', 'psychedelic', 'hypnotic', 'optical illusion', 'kaleidoscope'],
            ai: filterCategories.ai.terms,
            all: allSearchTerms
        };

        // Active search terms (start empty for ALL art - uses wildcard search)
        let searchTerms = [];

        function showLoading(show = true, status = null) {
            const screen = document.getElementById('loadingScreen');
            const statusEl = document.getElementById('loadingStatus');
            if (screen) {
                if (show) {
                    screen.classList.remove('hidden');
                    screen.style.display = 'flex';
                    // Start cycling through random phrases
                    startRandomLoadingPhrases();
                    // Set initial phrase
                    if (statusEl) statusEl.textContent = status || getRandomLoadingPhrase();
                } else {
                    screen.classList.add('hidden');
                    // Stop the phrase cycling
                    stopRandomLoadingPhrases();
                    // Remove from DOM after fade animation
                    setTimeout(() => {
                        if (screen.classList.contains('hidden')) {
                            screen.style.display = 'none';
                        }
                    }, 500);
                }
            }
        }

        // Fun random loading phrases
        const loadingPhrases = [
            // Tech/Art humor
            'DOWNLOADING MORE RAM...',
            'CONSULTING THE PIXELS...',
            'ASKING THE INTERNET NICELY...',
            'BRIBING THE SERVERS...',
            'RETICULATING SPLINES...',
            'CALIBRATING CHAOS...',
            'DEFRAGMENTING CREATIVITY...',
            'COMPILING VIBES...',
            'RENDERING EMOTIONS...',
            'BUFFERING AESTHETICS...',
            // Random nonsense
            'SUMMONING THE ART DEMONS...',
            'CONVINCING ELECTRONS TO COOPERATE...',
            'TEACHING AI ABOUT FEELINGS...',
            'ASKING A WIZARD FOR HELP...',
            'DIVIDING BY ZERO...',
            'REVERSING ENTROPY...',
            'QUANTUM TUNNELING...',
            'HACKING THE MAINFRAME...',
            'UPLOADING TO THE CLOUD (THE ACTUAL SKY)...',
            'CHECKING IF ART EXISTS...',
            // Gen Z/Internet culture
            'NO THOUGHTS JUST VIBES...',
            'DOING A LITTLE TROLLING...',
            'IT\'S GIVING... LOADING...',
            'SLAY MOMENT INCOMING...',
            'VERY DEMURE, VERY MINDFUL...',
            'THIS IS GIVING MAIN CHARACTER ENERGY...',
            // Out of context
            'THE MITOCHONDRIA IS THE POWERHOUSE...',
            'CALL THAT A KNIFE?...',
            'ANYWAY, HERE\'S WONDERWALL...',
            'I SHOULD BUY A BOAT...',
            'INSTRUCTIONS UNCLEAR...',
            'BUT WAIT, THERE\'S MORE...',
            'LET ME COOK...',
            'TRUST THE PROCESS...',
            'LOADING LOADING LOADING...',
            'ALMOST THERE... PROBABLY...',
            // Art specific
            'STEALING FROM MUSEUMS...',
            'ASKING PICASSO FOR TIPS...',
            'MAKING BOB ROSS PROUD...',
            'FINDING THE HAPPY LITTLE TREES...',
            'CHANNELING PURE CHAOS...'
        ];

        // Silly NSFW loading phrases (playfully scolding)
        const nsfwLoadingPhrases = [
            'OH YOU BAD BOY...',
            'I\'M GONNA TELL YOUR MOM...',
            'NAUGHTY NAUGHTY...',
            'CLOSING MY EYES WHILE LOADING...',
            'HOPE NOBODY\'S BEHIND YOU...',
            'INCOGNITO MODE RECOMMENDED...',
            'YOU SURE ABOUT THIS?...',
            'LOCKING THE DOOR FOR YOU...',
            'PRETENDING I DIDN\'T SEE THAT CLICK...',
            'YOUR SEARCH HISTORY WEEPS...',
            'FBI AGENT LOOKING AWAY...',
            'VPN ACTIVATED... JUST KIDDING...',
            'PARENTAL CONTROLS? NEVER HEARD OF HER...',
            'BONK! GO TO HORNY JAIL...',
            'THIS BETTER BE FOR "ART"...',
            'YOUR GRANDMOTHER WOULD BE DISAPPOINTED...',
            'GOD IS WATCHING... BUT SO ARE YOU...',
            'RESPECT THE ARTWORK... IF YOU CAN...',
            'CLEAR BROWSER HISTORY LATER...',
            'SHAME.EXE LOADING...',
            'ACTIVATING ADULT MODE...',
            'WARNING: SPICY CONTENT AHEAD...',
            'I WON\'T JUDGE... MUCH...',
            'PURELY ACADEMIC INTEREST, RIGHT?...',
            'ART APPRECIATION INTENSIFIES...'
        ];

        function getRandomLoadingPhrase() {
            // Use NSFW phrases when in NSFW mode
            if (!sfwMode) {
                return nsfwLoadingPhrases[Math.floor(Math.random() * nsfwLoadingPhrases.length)];
            }
            return loadingPhrases[Math.floor(Math.random() * loadingPhrases.length)];
        }

        function updateLoadingStatus(status) {
            const statusEl = document.getElementById('loadingStatus');
            if (statusEl) statusEl.textContent = status || getRandomLoadingPhrase();
        }

        // Cycle through random phrases during loading
        let loadingPhraseInterval = null;
        function startRandomLoadingPhrases() {
            if (loadingPhraseInterval) clearInterval(loadingPhraseInterval);
            loadingPhraseInterval = setInterval(() => {
                const statusEl = document.getElementById('loadingStatus');
                if (statusEl) statusEl.textContent = getRandomLoadingPhrase();
            }, 1500);
        }
        function stopRandomLoadingPhrases() {
            if (loadingPhraseInterval) {
                clearInterval(loadingPhraseInterval);
                loadingPhraseInterval = null;
            }
        }

        function updateLoadingProgress(percent) {
            const progressBar = document.querySelector('.loading-progress-bar');
            if (progressBar) {
                // Remove the default animation and set actual progress
                progressBar.style.animation = 'progress-flow 2s linear infinite';
                progressBar.style.width = Math.min(percent, 100) + '%';
                progressBar.style.transition = 'width 0.3s ease-out';
            }
        }

        function resetLoadingProgress() {
            const progressBar = document.querySelector('.loading-progress-bar');
            if (progressBar) {
                progressBar.style.animation = 'progress-flow 2s linear infinite, progress-width 3s ease-out forwards';
                progressBar.style.width = '0%';
                progressBar.style.transition = '';
            }
        }

        async function loadGifs() {
            const track = document.getElementById('scrollTrack');
            showLoading(true, 'CONNECTING TO SOURCES...');

            try {
                const allPromises = [];

                // Base limit per source (will be multiplied by weight)
                const baseLimit = 35;

                // Combine search terms with selected artists
                const effectiveSearchTerms = [...searchTerms, ...selectedArtists];

                updateLoadingStatus('FETCHING ART...');

                // === TENOR ===
                if (sourcesEnabled.tenor && sourceWeights.tenor > 0) {
                    const limit = Math.round(baseLimit * sourceWeights.tenor);
                    // Wildcard: ALL ART TYPES when no filters selected
                    let terms = effectiveSearchTerms.length === 0
                        ? ['art', 'animation', 'illustration', 'aesthetic', 'abstract', 'fantasy', 'digital art', 'painting', 'trippy', 'nature', 'space', 'neon', 'colorful', 'beautiful', 'surreal']
                        : effectiveSearchTerms;
                    const tenorPromises = terms.map(term =>
                        fetch(`https://tenor.googleapis.com/v2/search?q=${encodeURIComponent(term)}&key=${TENOR_KEY}&limit=${limit}&media_filter=gif`)
                            .then(r => r.json())
                            .then(data => ({ type: 'tenor', data }))
                            .catch(() => ({ type: 'tenor', data: { results: [] } }))
                    );
                    allPromises.push(...tenorPromises);
                }

                // === GIPHY ===
                if (sourcesEnabled.giphy && sourceWeights.giphy > 0) {
                    const limit = Math.round(baseLimit * sourceWeights.giphy);
                    // Wildcard: ALL ART TYPES when no filters selected
                    let terms = effectiveSearchTerms.length === 0
                        ? ['art', 'animation', 'illustration', 'aesthetic', 'abstract', 'fantasy', 'pixel art', 'retro', 'trippy', 'nature', 'space', 'neon', 'colorful', 'loop', 'satisfying']
                        : effectiveSearchTerms;
                    const giphyRating = sfwMode ? 'pg-13' : 'r'; // SFW = pg-13, NSFW = r
                    const giphyPromises = terms.map(term =>
                        fetch(`https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_KEY}&q=${encodeURIComponent(term)}&limit=${limit}&rating=${giphyRating}`)
                            .then(r => r.json())
                            .then(data => ({ type: 'giphy', data }))
                            .catch(() => ({ type: 'giphy', data: { data: [] } }))
                    );
                    allPromises.push(...giphyPromises);
                }

                // === REDDIT ===
                if (sourcesEnabled.reddit && sourceWeights.reddit > 0) {
                    const limit = Math.round(baseLimit * sourceWeights.reddit);
                    // Wildcard: search broad terms when no filters selected
                    const redditSearchTerms = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.slice(0, 8)
                        : ['cool', 'interesting', 'beautiful', 'amazing', 'wow', 'satisfying', 'art', 'photography'];
                    const redditSearchPromises = redditSearchTerms.map(term =>
                        fetch(`https://www.reddit.com/search.json?q=${encodeURIComponent(term)}&type=link&limit=${limit}&sort=relevance`)
                            .then(r => r.json())
                            .then(data => ({ type: 'reddit-search', data, term }))
                            .catch(() => ({ type: 'reddit-search', data: { data: { children: [] } }, term }))
                    );
                    allPromises.push(...redditSearchPromises);
                    if (redditSubs.length > 0) {
                        const redditPromises = redditSubs.map(sub =>
                            fetch(`https://www.reddit.com/r/${sub}/hot.json?limit=${limit}`)
                                .then(r => r.json())
                                .then(data => ({ type: 'reddit', data, sub }))
                                .catch(() => ({ type: 'reddit', data: { data: { children: [] } }, sub }))
                        );
                        allPromises.push(...redditPromises);
                    }
                }

                // === OBJKT.COM (Tezos NFTs) ===
                if (sourcesEnabled.objkt && sourceWeights.objkt > 0) {
                    const limit = Math.round(50 * sourceWeights.objkt);
                    // Wildcard: broad tags for all types of NFT art when no filters
                    const objktTags = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.map(t => t.replace(/\s+/g, ''))
                        : ['art', 'photo', 'nature', 'abstract', 'portrait', 'landscape', 'animation', 'illustration', 'design', 'digital', '3d', 'surreal'];

                    // Build query based on whether an artist is specified
                    // Include listing/pricing data for marketplace info
                    let objktQuery;
                    if (objktArtistHandle) {
                        // Query by artist (wallet address or alias)
                        objktQuery = `
                            query GetArtistWork {
                                token(where: {
                                    creators: {
                                        holder: {
                                            _or: [
                                                {address: {_eq: "${objktArtistHandle}"}},
                                                {alias: {_ilike: "%${objktArtistHandle}%"}}
                                            ]
                                        }
                                    },
                                    mime: {_in: ["image/gif", "image/png", "image/jpeg", "video/mp4"]},
                                    artifact_uri: {_is_null: false}
                                }, limit: ${limit}, order_by: {timestamp: desc}) {
                                    pk
                                    name
                                    mime
                                    artifact_uri
                                    display_uri
                                    thumbnail_uri
                                    supply
                                    editions
                                    tags { tag { name } }
                                    creators { holder { address alias } }
                                    fa_contract
                                    token_id
                                    listings_active(limit: 1, order_by: {price: asc}) {
                                        price
                                        currency { symbol decimals }
                                    }
                                    listings_active_aggregate { aggregate { count } }
                                }
                            }
                        `;
                    } else {
                        // Query recent tokens - simplified for reliability
                        objktQuery = `
                            query GetRecentArt {
                                token(
                                    where: {
                                        artifact_uri: {_is_null: false},
                                        display_uri: {_is_null: false}
                                    },
                                    limit: ${limit},
                                    order_by: {timestamp: desc}
                                ) {
                                    pk
                                    name
                                    mime
                                    artifact_uri
                                    display_uri
                                    thumbnail_uri
                                    supply
                                    token_id
                                    fa_contract
                                    creators {
                                        holder {
                                            address
                                            alias
                                        }
                                    }
                                    listings_active(limit: 1, order_by: {price: asc}) {
                                        price
                                        currency {
                                            symbol
                                            decimals
                                        }
                                    }
                                }
                            }
                        `;
                    }

                    console.log('objkt: starting fetch with query limit:', limit);
                    const objktPromise = fetch('https://data.objkt.com/v3/graphql', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ query: objktQuery })
                    })
                        .then(r => {
                            console.log('objkt: received response, status:', r.status);
                            if (!r.ok) {
                                console.error('objkt API error:', r.status, r.statusText);
                                return { data: { token: [] } };
                            }
                            return r.json();
                        })
                        .then(data => {
                            console.log('objkt raw response:', data);
                            if (data.errors) {
                                console.error('objkt GraphQL errors:', data.errors);
                            }
                            return { type: 'objkt', data };
                        })
                        .catch(err => {
                            console.error('objkt fetch failed:', err);
                            return { type: 'objkt', data: { data: { token: [] } } };
                        });

                    allPromises.push(objktPromise);
                    console.log('objkt: promise added to allPromises');
                }

                // === EXCHANGE.ART (Solana NFTs) ===
                if (sourcesEnabled.exchange) {
                    const exchangeTags = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.slice(0, 8)
                        : ['art', 'abstract', 'generative', 'digital', 'photography', 'illustration', 'animation', 'portrait'];

                    const exchangePromises = exchangeTags.map(tag =>
                        fetch(`https://api.exchange.art/v2/nfts?q=${encodeURIComponent(tag)}&limit=20&sort=recent`)
                            .then(r => r.json())
                            .then(data => ({ type: 'exchange', data, tag }))
                            .catch(() => ({ type: 'exchange', data: { nfts: [] }, tag }))
                    );
                    allPromises.push(...exchangePromises);
                }

                // === MALLOW.ART ===
                if (sourcesEnabled.mallow) {
                    const mallowTags = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.slice(0, 5)
                        : ['art', 'digital', 'abstract', 'photography', 'illustration'];

                    const mallowPromises = mallowTags.map(tag =>
                        fetch(`https://mallow.art/api/artworks?search=${encodeURIComponent(tag)}&limit=30`)
                            .then(r => r.json())
                            .then(data => ({ type: 'mallow', data, tag }))
                            .catch(() => ({ type: 'mallow', data: { artworks: [] }, tag }))
                    );
                    allPromises.push(...mallowPromises);
                }

                // === FOSTER MARKETPLACE ===
                if (sourcesEnabled.foster) {
                    const fosterTags = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.slice(0, 5)
                        : ['art', 'generative', 'abstract', 'photography', 'digital'];

                    const fosterPromises = fosterTags.map(tag =>
                        fetch(`https://api.fostermarketplace.xyz/v1/artworks?q=${encodeURIComponent(tag)}&limit=30`)
                            .then(r => r.json())
                            .then(data => ({ type: 'foster', data, tag }))
                            .catch(() => ({ type: 'foster', data: { items: [] }, tag }))
                    );
                    allPromises.push(...fosterPromises);
                }

                // === DEVIANTART (via backend.deviantart.com API) ===
                if (sourcesEnabled.deviantart) {
                    const daTags = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.slice(0, 5)
                        : ['digital art', 'fantasy art', 'illustration', 'concept art', 'abstract'];

                    const daPromises = daTags.map(tag =>
                        fetch(`https://backend.deviantart.com/rss.xml?type=deviation&q=${encodeURIComponent(tag)}`)
                            .then(r => r.text())
                            .then(xml => {
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(xml, 'text/xml');
                                const items = doc.querySelectorAll('item');
                                const results = [];
                                items.forEach(item => {
                                    const title = item.querySelector('title')?.textContent;
                                    const creator = item.querySelector('creator')?.textContent;
                                    const mediaContent = item.querySelector('content');
                                    const thumbnail = item.querySelector('thumbnail');
                                    const url = mediaContent?.getAttribute('url') || thumbnail?.getAttribute('url');
                                    if (url) {
                                        results.push({ title, creator, url });
                                    }
                                });
                                return { type: 'deviantart', data: results, tag };
                            })
                            .catch(() => ({ type: 'deviantart', data: [], tag }))
                    );
                    allPromises.push(...daPromises);
                }

                // === TUMBLR (tagged posts) ===
                if (sourcesEnabled.tumblr) {
                    const tumblrTags = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.slice(0, 5).map(t => t.replace(/\s+/g, ''))
                        : ['art', 'digitalart', 'illustration', 'aesthetic', 'photography'];

                    const tumblrPromises = tumblrTags.map(tag =>
                        fetch(`https://api.tumblr.com/v2/tagged?tag=${encodeURIComponent(tag)}&api_key=fuiKNFp9vQFvjLNvx4sUwti4Yb5yGutBN4Xh10LXZhhRKjWlV4`)
                            .then(r => r.json())
                            .then(data => ({ type: 'tumblr', data: data.response || [], tag }))
                            .catch(() => ({ type: 'tumblr', data: [], tag }))
                    );
                    allPromises.push(...tumblrPromises);
                }

                // === BLUESKY (public API) ===
                if (sourcesEnabled.bluesky) {
                    const bskyTags = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.slice(0, 5)
                        : ['art', 'digital art', 'illustration', 'photography', 'creative'];

                    const bskyPromises = bskyTags.map(tag =>
                        fetch(`https://public.api.bsky.app/xrpc/app.bsky.feed.searchPosts?q=${encodeURIComponent(tag)}&limit=30`)
                            .then(r => r.json())
                            .then(data => ({ type: 'bluesky', data: data.posts || [], tag }))
                            .catch(() => ({ type: 'bluesky', data: [], tag }))
                    );
                    allPromises.push(...bskyPromises);
                }

                // === ARCHIVE.ORG ===
                if (sourcesEnabled.archive) {
                    const archiveTags = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.slice(0, 5)
                        : ['art', 'video art', 'animation', 'experimental', 'photography'];

                    const archivePromises = archiveTags.map(tag =>
                        fetch(`https://archive.org/advancedsearch.php?q=${encodeURIComponent(tag)}&fl=identifier,title,creator,description&rows=30&output=json&mediatype=movies,image`)
                            .then(r => r.json())
                            .then(data => ({ type: 'archive', data: data.response?.docs || [], tag }))
                            .catch(() => ({ type: 'archive', data: [], tag }))
                    );
                    allPromises.push(...archivePromises);
                }

                // === WIKIPEDIA (Commons) ===
                if (sourcesEnabled.wikipedia) {
                    const wikiTags = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.slice(0, 3)
                        : ['art', 'digital art', 'painting'];

                    const wikiPromises = wikiTags.map(tag =>
                        fetch(`https://commons.wikimedia.org/w/api.php?action=query&list=search&srsearch=${encodeURIComponent(tag)}&srnamespace=6&srlimit=30&format=json&origin=*`)
                            .then(r => r.json())
                            .then(data => ({ type: 'wikipedia', data: data.query?.search || [], tag }))
                            .catch(() => ({ type: 'wikipedia', data: [], tag }))
                    );
                    allPromises.push(...wikiPromises);
                }

                // === PEXELS (Images + Videos) ===
                if (sourcesEnabled.pexels && sourceWeights.pexels > 0) {
                    const limit = Math.round(15 * sourceWeights.pexels);
                    const pexelsTags = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.slice(0, 4)
                        : ['abstract', 'art', 'digital', 'colorful'];

                    // Pexels photos
                    const pexelsPhotoPromises = pexelsTags.map(tag =>
                        fetch(`https://api.pexels.com/v1/search?query=${encodeURIComponent(tag)}&per_page=${limit}`, {
                            headers: { 'Authorization': PEXELS_KEY }
                        })
                            .then(r => r.json())
                            .then(data => ({ type: 'pexels-photo', data: data.photos || [], tag }))
                            .catch(() => ({ type: 'pexels-photo', data: [], tag }))
                    );
                    allPromises.push(...pexelsPhotoPromises);

                    // Pexels videos
                    const pexelsVideoPromises = pexelsTags.slice(0, 2).map(tag =>
                        fetch(`https://api.pexels.com/videos/search?query=${encodeURIComponent(tag)}&per_page=${limit}`, {
                            headers: { 'Authorization': PEXELS_KEY }
                        })
                            .then(r => r.json())
                            .then(data => ({ type: 'pexels-video', data: data.videos || [], tag }))
                            .catch(() => ({ type: 'pexels-video', data: [], tag }))
                    );
                    allPromises.push(...pexelsVideoPromises);
                }

                // === PIXABAY (Images + Videos - Public Domain) ===
                if (sourcesEnabled.pixabay && sourceWeights.pixabay > 0) {
                    const limit = Math.round(20 * sourceWeights.pixabay);
                    const pixabayTags = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.slice(0, 4)
                        : ['abstract', 'art', 'digital', 'pattern'];

                    // Pixabay images
                    const pixabayImagePromises = pixabayTags.map(tag =>
                        fetch(`https://pixabay.com/api/?key=${PIXABAY_KEY}&q=${encodeURIComponent(tag)}&per_page=${limit}&image_type=all`)
                            .then(r => r.json())
                            .then(data => ({ type: 'pixabay-image', data: data.hits || [], tag }))
                            .catch(() => ({ type: 'pixabay-image', data: [], tag }))
                    );
                    allPromises.push(...pixabayImagePromises);

                    // Pixabay videos
                    const pixabayVideoPromises = pixabayTags.slice(0, 2).map(tag =>
                        fetch(`https://pixabay.com/api/videos/?key=${PIXABAY_KEY}&q=${encodeURIComponent(tag)}&per_page=${limit}`)
                            .then(r => r.json())
                            .then(data => ({ type: 'pixabay-video', data: data.hits || [], tag }))
                            .catch(() => ({ type: 'pixabay-video', data: [], tag }))
                    );
                    allPromises.push(...pixabayVideoPromises);
                }

                // === NASA (Images + Videos - Public Domain) ===
                if (sourcesEnabled.nasa && sourceWeights.nasa > 0) {
                    const nasaTags = effectiveSearchTerms.length > 0
                        ? effectiveSearchTerms.slice(0, 3)
                        : ['nebula', 'galaxy', 'earth', 'aurora'];

                    const nasaPromises = nasaTags.map(tag =>
                        fetch(`https://images-api.nasa.gov/search?q=${encodeURIComponent(tag)}&media_type=image,video`)
                            .then(r => r.json())
                            .then(data => ({ type: 'nasa', data: data.collection?.items || [], tag }))
                            .catch(() => ({ type: 'nasa', data: [], tag }))
                    );
                    allPromises.push(...nasaPromises);
                }

                console.log('Waiting for', allPromises.length, 'promises to resolve...');
                const results = await Promise.all(allPromises);
                console.log('All promises resolved. Got', results.length, 'results');

                updateLoadingStatus('PROCESSING ' + results.length + ' FEEDS...');

                // Process results by type
                results.forEach(result => {
                    if (result.type === 'tenor' && result.data.results) {
                        result.data.results.forEach(item => {
                            const animatedUrl = item.media_formats?.gif?.url || item.media_formats?.tinygif?.url;
                            // Tenor: use nanogif (low res) or tinygif as static-ish alternative (first frame approximation)
                            const staticUrl = item.media_formats?.nanogif?.url || item.media_formats?.tinygif?.url || animatedUrl;
                            addGifIfUnique({
                                id: 'tenor_' + item.id,
                                title: item.content_description || 'Untitled',
                                username: item.itemurl ? new URL(item.itemurl).pathname.split('/')[1] : 'Unknown',
                                tags: item.tags || [],
                                source: 'Tenor',
                                images: {
                                    fixed_height: { url: animatedUrl },
                                    original: { url: item.media_formats?.gif?.url },
                                    static: { url: staticUrl }
                                }
                            });
                        });
                    }

                    if (result.type === 'giphy' && result.data.data) {
                        result.data.data.forEach(item => {
                            addGifIfUnique({
                                id: 'giphy_' + item.id,
                                title: item.title || 'Untitled',
                                username: item.username || item.user?.username || 'Unknown',
                                tags: item.tags || [],
                                source: 'Giphy',
                                images: {
                                    fixed_height: { url: item.images?.fixed_height?.url },
                                    original: { url: item.images?.original?.url },
                                    // Giphy provides _still versions for static images
                                    static: { url: item.images?.fixed_height_still?.url || item.images?.original_still?.url }
                                }
                            });
                        });
                    }

                    // Process Reddit subreddit results
                    if (result.type === 'reddit' && result.data.data && result.data.data.children) {
                        result.data.data.children.forEach(post => {
                            const data = post.data;
                            if (data.url && (
                                data.url.endsWith('.gif') ||
                                data.url.includes('i.redd.it') ||
                                data.url.includes('i.imgur.com')
                            )) {
                                let url = data.url;
                                if (url.endsWith('.gifv')) url = url.replace('.gifv', '.gif');

                                addGifIfUnique({
                                    id: 'reddit_' + data.id,
                                    title: data.title || 'Untitled',
                                    username: data.author || 'Unknown',
                                    tags: [data.subreddit],
                                    source: 'Reddit r/' + data.subreddit,
                                    images: {
                                        fixed_height: { url: url },
                                        original: { url: url }
                                    }
                                });
                            }
                        });
                    }

                    // Process Reddit search results
                    if (result.type === 'reddit-search' && result.data.data && result.data.data.children) {
                        result.data.data.children.forEach(post => {
                            const data = post.data;
                            if (data.url && (
                                data.url.endsWith('.gif') ||
                                data.url.endsWith('.png') ||
                                data.url.endsWith('.jpg') ||
                                data.url.includes('i.redd.it') ||
                                data.url.includes('i.imgur.com')
                            )) {
                                let url = data.url;
                                if (url.endsWith('.gifv')) url = url.replace('.gifv', '.gif');

                                addGifIfUnique({
                                    id: 'reddit_' + data.id,
                                    title: data.title || 'Untitled',
                                    username: data.author || 'Unknown',
                                    tags: [result.term, data.subreddit].filter(Boolean),
                                    source: `Reddit (${result.term})`,
                                    images: {
                                        fixed_height: { url: url },
                                        original: { url: url }
                                    }
                                });
                            }
                        });
                    }

                    if (result.type === 'objkt') {
                        try {
                            const tokens = result.data?.data?.token || [];
                            console.log(`objkt returned ${tokens.length} tokens`, result.data);
                            let objktAddedCount = 0;
                            tokens.forEach(token => {
                                try {
                                    // Convert IPFS URIs to gateway URLs
                                    let displayUrl = token.display_uri || token.thumbnail_uri || token.artifact_uri;
                                    if (displayUrl) {
                                        if (displayUrl.startsWith('ipfs://')) {
                                            // Handle ipfs:// protocol
                                            displayUrl = displayUrl.replace('ipfs://', 'https://nftstorage.link/ipfs/');
                                        } else if (!displayUrl.startsWith('http')) {
                                            // Assume anything not http is an IPFS CID
                                            displayUrl = 'https://nftstorage.link/ipfs/' + displayUrl;
                                        }
                                    }

                                    if (displayUrl) {
                                        const artist = token.creators?.[0]?.holder?.alias ||
                                                      token.creators?.[0]?.holder?.address?.slice(0, 8) + '...' ||
                                                      'Unknown';
                                        // Tags not included in simplified query
                                        const tags = [];

                                        // Parse pricing info
                                        const listing = token.listings_active?.[0];
                                        let price = null;
                                        let priceDisplay = null;
                                        let available = false;

                                        if (listing) {
                                            const decimals = listing.currency?.decimals || 6;
                                            const symbol = listing.currency?.symbol || 'XTZ';
                                            price = listing.price / Math.pow(10, decimals);
                                            priceDisplay = `${price.toFixed(2)} ${symbol}`;
                                            available = true;
                                        }

                                        // Parse edition info (simplified)
                                        const totalSupply = token.supply || 1;
                                        const isOneOfOne = totalSupply === 1;
                                        const editionsAvailable = listing ? 1 : 0;
                                        let editionDisplay = isOneOfOne ? '1/1' : `${totalSupply} editions`;

                                        // Build objkt.com URL
                                        const objktUrl = token.fa_contract && token.token_id
                                            ? `https://objkt.com/tokens/${token.fa_contract}/${token.token_id}`
                                            : `https://objkt.com/tokens/${token.pk}`;

                                        const added = addGifIfUnique({
                                            id: 'objkt_' + token.pk,
                                            title: token.name || 'Untitled',
                                            username: artist,
                                            tags: tags,
                                            source: 'objkt.com',
                                            mime: token.mime,
                                            images: {
                                                fixed_height: { url: displayUrl },
                                                original: { url: displayUrl }
                                            },
                                            // NFT marketplace data
                                            externalUrl: objktUrl,
                                            price: price,
                                            priceDisplay: priceDisplay,
                                            available: available,
                                            supply: totalSupply,
                                            editionsAvailable: editionsAvailable,
                                            editionDisplay: editionDisplay,
                                            isOneOfOne: isOneOfOne
                                        });
                                        if (added) objktAddedCount++;
                                    }
                                } catch (tokenErr) {
                                    console.error('Error processing objkt token:', tokenErr, token);
                                }
                            });
                            console.log(`objkt: added ${objktAddedCount} unique items to gallery`);
                        } catch (objktErr) {
                            console.error('Error processing objkt results:', objktErr);
                        }
                    }

                    // Process Exchange.art results
                    if (result.type === 'exchange' && result.data.nfts) {
                        result.data.nfts.forEach(nft => {
                            const imageUrl = nft.image || nft.thumbnail || nft.media?.uri;
                            if (imageUrl) {
                                addGifIfUnique({
                                    id: 'exchange_' + nft.mint,
                                    title: nft.name || 'Untitled',
                                    username: nft.artist?.name || nft.creator || 'Unknown',
                                    tags: [result.tag, ...(nft.tags || [])].filter(Boolean),
                                    source: 'Exchange.art (Solana)',
                                    images: {
                                        fixed_height: { url: imageUrl },
                                        original: { url: imageUrl }
                                    }
                                });
                            }
                        });
                    }

                    // Process mallow.art results
                    if (result.type === 'mallow' && result.data.artworks) {
                        result.data.artworks.forEach(art => {
                            const imageUrl = art.image || art.thumbnail || art.media_url;
                            if (imageUrl) {
                                addGifIfUnique({
                                    id: 'mallow_' + art.id,
                                    title: art.title || art.name || 'Untitled',
                                    username: art.artist?.name || art.creator || 'Unknown',
                                    tags: [result.tag, ...(art.tags || [])].filter(Boolean),
                                    source: 'mallow.art',
                                    images: {
                                        fixed_height: { url: imageUrl },
                                        original: { url: imageUrl }
                                    }
                                });
                            }
                        });
                    }

                    // Process Foster results
                    if (result.type === 'foster' && result.data.items) {
                        result.data.items.forEach(item => {
                            const imageUrl = item.image || item.thumbnail || item.media;
                            if (imageUrl) {
                                addGifIfUnique({
                                    id: 'foster_' + item.id,
                                    title: item.name || item.title || 'Untitled',
                                    username: item.artist || item.creator || 'Unknown',
                                    tags: [result.tag, ...(item.tags || [])].filter(Boolean),
                                    source: 'Foster',
                                    images: {
                                        fixed_height: { url: imageUrl },
                                        original: { url: imageUrl }
                                    }
                                });
                            }
                        });
                    }

                    // Process DeviantArt results
                    if (result.type === 'deviantart' && Array.isArray(result.data)) {
                        result.data.forEach((item, i) => {
                            if (item.url) {
                                addGifIfUnique({
                                    id: 'da_' + result.tag + '_' + i,
                                    title: item.title || 'Untitled',
                                    username: item.creator || 'Unknown',
                                    tags: [result.tag],
                                    source: 'DeviantArt',
                                    images: {
                                        fixed_height: { url: item.url },
                                        original: { url: item.url }
                                    }
                                });
                            }
                        });
                    }

                    // Process Tumblr results
                    if (result.type === 'tumblr' && Array.isArray(result.data)) {
                        result.data.forEach(post => {
                            let imageUrl = null;
                            if (post.photos && post.photos[0]) {
                                imageUrl = post.photos[0].original_size?.url || post.photos[0].alt_sizes?.[0]?.url;
                            }
                            if (imageUrl) {
                                addGifIfUnique({
                                    id: 'tumblr_' + post.id,
                                    title: post.summary || post.caption?.replace(/<[^>]*>/g, '').slice(0, 50) || 'Untitled',
                                    username: post.blog_name || 'Unknown',
                                    tags: post.tags || [result.tag],
                                    source: 'Tumblr',
                                    images: {
                                        fixed_height: { url: imageUrl },
                                        original: { url: imageUrl }
                                    }
                                });
                            }
                        });
                    }

                    // Process Bluesky results
                    if (result.type === 'bluesky' && Array.isArray(result.data)) {
                        result.data.forEach(post => {
                            const embed = post.embed;
                            let imageUrl = null;
                            if (embed?.images && embed.images[0]) {
                                imageUrl = embed.images[0].fullsize || embed.images[0].thumb;
                            }
                            if (imageUrl) {
                                addGifIfUnique({
                                    id: 'bsky_' + post.uri,
                                    title: post.record?.text?.slice(0, 60) || 'Untitled',
                                    username: post.author?.handle || post.author?.displayName || 'Unknown',
                                    tags: [result.tag],
                                    source: 'Bluesky',
                                    images: {
                                        fixed_height: { url: imageUrl },
                                        original: { url: imageUrl }
                                    }
                                });
                            }
                        });
                    }

                    // Process Archive.org results
                    if (result.type === 'archive' && Array.isArray(result.data)) {
                        result.data.forEach(item => {
                            const imageUrl = `https://archive.org/services/img/${item.identifier}`;
                            addGifIfUnique({
                                id: 'archive_' + item.identifier,
                                title: item.title || 'Untitled',
                                username: item.creator || 'Unknown',
                                tags: [result.tag],
                                source: 'Archive.org',
                                images: {
                                    fixed_height: { url: imageUrl },
                                    original: { url: imageUrl }
                                }
                            });
                        });
                    }

                    // Process Wikipedia Commons results
                    if (result.type === 'wikipedia' && Array.isArray(result.data)) {
                        result.data.forEach(item => {
                            const fileName = item.title.replace('File:', '');
                            const imageUrl = `https://commons.wikimedia.org/wiki/Special:FilePath/${encodeURIComponent(fileName)}?width=400`;
                            addGifIfUnique({
                                id: 'wiki_' + item.pageid,
                                title: fileName.replace(/_/g, ' ').replace(/\.\w+$/, ''),
                                username: 'Wikimedia Commons',
                                tags: [result.tag],
                                source: 'Wikipedia',
                                images: {
                                    fixed_height: { url: imageUrl },
                                    original: { url: imageUrl }
                                }
                            });
                        });
                    }

                    // Process Pexels photo results
                    if (result.type === 'pexels-photo' && Array.isArray(result.data)) {
                        result.data.forEach(photo => {
                            addGifIfUnique({
                                id: 'pexels_' + photo.id,
                                title: photo.alt || 'Pexels Photo',
                                username: photo.photographer || 'Unknown',
                                tags: [result.tag],
                                source: 'Pexels',
                                images: {
                                    fixed_height: { url: photo.src?.medium || photo.src?.small },
                                    original: { url: photo.src?.large || photo.src?.original }
                                }
                            });
                        });
                    }

                    // Process Pexels video results
                    if (result.type === 'pexels-video' && Array.isArray(result.data)) {
                        result.data.forEach(video => {
                            const videoFile = video.video_files?.find(f => f.quality === 'sd') || video.video_files?.[0];
                            const thumbUrl = video.image || video.video_pictures?.[0]?.picture;
                            if (thumbUrl) {
                                addGifIfUnique({
                                    id: 'pexels_v_' + video.id,
                                    title: 'Pexels Video',
                                    username: video.user?.name || 'Unknown',
                                    tags: [result.tag, 'video'],
                                    source: 'Pexels Video',
                                    images: {
                                        fixed_height: { url: thumbUrl },
                                        original: { url: thumbUrl }
                                    }
                                });
                            }
                        });
                    }

                    // Process Pixabay image results (Public Domain)
                    if (result.type === 'pixabay-image' && Array.isArray(result.data)) {
                        result.data.forEach(img => {
                            addGifIfUnique({
                                id: 'pixabay_' + img.id,
                                title: img.tags || 'Pixabay Image',
                                username: img.user || 'Unknown',
                                tags: [result.tag, 'public domain'],
                                source: 'Pixabay (CC0)',
                                images: {
                                    fixed_height: { url: img.webformatURL },
                                    original: { url: img.largeImageURL }
                                }
                            });
                        });
                    }

                    // Process Pixabay video results (Public Domain)
                    if (result.type === 'pixabay-video' && Array.isArray(result.data)) {
                        result.data.forEach(vid => {
                            const thumbUrl = `https://i.vimeocdn.com/video/${vid.picture_id}_640x360.jpg`;
                            addGifIfUnique({
                                id: 'pixabay_v_' + vid.id,
                                title: vid.tags || 'Pixabay Video',
                                username: vid.user || 'Unknown',
                                tags: [result.tag, 'video', 'public domain'],
                                source: 'Pixabay Video (CC0)',
                                images: {
                                    fixed_height: { url: thumbUrl },
                                    original: { url: thumbUrl }
                                }
                            });
                        });
                    }

                    // Process NASA results (Public Domain)
                    if (result.type === 'nasa' && Array.isArray(result.data)) {
                        result.data.forEach(item => {
                            const data = item.data?.[0];
                            const links = item.links;
                            const thumbUrl = links?.find(l => l.rel === 'preview')?.href;
                            if (thumbUrl && data) {
                                addGifIfUnique({
                                    id: 'nasa_' + data.nasa_id,
                                    title: data.title || 'NASA Image',
                                    username: data.center || 'NASA',
                                    tags: [result.tag, 'space', 'public domain'],
                                    source: 'NASA',
                                    images: {
                                        fixed_height: { url: thumbUrl },
                                        original: { url: thumbUrl.replace('~thumb', '~medium') }
                                    }
                                });
                            }
                        });
                    }
                });

                // Remove duplicates by ID
                const seen = new Set();
                allGifs = allGifs.filter(gif => {
                    if (seen.has(gif.id)) return false;
                    seen.add(gif.id);
                    return true;
                });

                // Shuffle
                allGifs.sort(() => Math.random() - 0.5);

                updateLoadingStatus('RENDERING ' + allGifs.length + ' ARTWORKS...');

                console.log(`Loaded ${allGifs.length} GIFs`);

                // Small delay to show the final status
                setTimeout(() => {
                    renderGallery();
                    showLoading(false);
                }, 500);
            } catch (e) {
                console.error('Error loading GIFs:', e);
                showLoading(false);
                track.innerHTML = '<div class="loading">Error loading. Refresh to try again.</div>';
            }
        }

        function renderGallery() {
            const container = document.getElementById('galleryContainer');
            const track = document.getElementById('scrollTrack');

            // Filter content based on modes
            let displayGifs = allGifs;
            // Filter flash content if seizure safe mode is on
            if (seizureSafeMode) {
                displayGifs = displayGifs.filter(gif =>
                    !hasFlashTags(gif.tags) && !hasFlashTitle(gif.title)
                );
            }
            // Filter NSFW content if SFW mode is on
            if (sfwMode) {
                displayGifs = displayGifs.filter(gif =>
                    !hasNsfwTags(gif.tags) && !hasNsfwTitle(gif.title)
                );
            }

            if (displayGifs.length === 0) {
                // Check if objkt is the only enabled source for a more specific message
                const enabledSources = Object.entries(sourcesEnabled).filter(([k,v]) => v).map(([k]) => k);
                const onlyObjkt = enabledSources.length === 1 && enabledSources[0] === 'objkt';
                const message = onlyObjkt
                    ? 'objkt.com is loading... NFTs may take a moment. Check browser console (F12) for details.'
                    : 'Try enabling more sources or changing filters';

                track.innerHTML = `
                    <div class="loading" style="text-align:center;padding:40px;">
                        <div style="font-size:1.5rem;margin-bottom:15px;">No content found</div>
                        <div style="color:#888;font-size:0.9rem;">${message}</div>
                        <button onclick="clearAllFilters();allSourcesOn();applyFilters();"
                                style="margin-top:20px;padding:12px 24px;background:#8338ec;color:#fff;border:none;border-radius:8px;cursor:pointer;font-size:1rem;">
                            Reset to All Art
                        </button>
                    </div>
                `;
                return;
            }

            // Card HTML generator - optimized with async decoding
            function makeCard(gif, idx) {
                // Use static image in seizure safe mode if available
                const url = seizureSafeMode && gif.images?.static?.url
                    ? gif.images.static.url
                    : (gif.images?.fixed_height?.url || gif.images?.original?.url);
                const title = gif.title || 'Untitled';
                const user = gif.username || gif.user?.username || 'Unknown';
                const source = gif.source || '';
                const tags = gif.tags || [];
                const firstTag = tags.length > 0 ? tags[0] : '';

                // NFT pricing and edition badge (for objkt and other NFT sources)
                let priceBadge = '';
                if (gif.source && gif.source.includes('objkt')) {
                    const editionText = gif.editionDisplay || '';
                    const editionClass = gif.isOneOfOne ? 'one-of-one' : '';
                    if (gif.priceDisplay) {
                        priceBadge = `<div class="price-badge available ${editionClass}">${gif.priceDisplay}<span class="edition-info">${editionText}</span></div>`;
                    } else {
                        priceBadge = `<div class="price-badge sold-out ${editionClass}">Sold<span class="edition-info">${editionText}</span></div>`;
                    }
                }

                return `
                    <div class="art-card" style="width:${cardSize}px;" onclick="openFullscreen(${idx})">
                        <div class="art-media" style="height:${cardSize}px;">
                            <img src="${url}" alt="${title}" loading="lazy" decoding="async">
                            ${priceBadge}
                        </div>
                        <button class="bookmark-btn ${isBookmarked(gif.id) ? 'saved' : ''}"
                                onclick="event.stopPropagation(); toggleBookmark(${idx})">
                            ${isBookmarked(gif.id) ? 'â˜…' : 'â˜†'}
                        </button>
                        <div class="art-info">
                            <div><span style="color:#8338ec;">${source}</span></div>
                            <div style="color:#fff;">${user}</div>
                            ${firstTag ? `<div style="color:#3a86ff;font-size:0.7rem;">#${firstTag}</div>` : ''}
                        </div>
                    </div>
                `;
            }

            // First, deduplicate by URL to remove exact duplicates
            function deduplicateByUrl(gifs) {
                const seen = new Set();
                return gifs.filter(gif => {
                    const url = gif.images?.fixed_height?.url || gif.images?.original?.url;
                    if (!url || seen.has(url)) return false;
                    seen.add(url);
                    return true;
                });
            }

            // Smart shuffle: spread out same artists and prevent adjacent duplicates
            function smartShuffle(gifs) {
                // First remove exact URL duplicates
                const uniqueGifs = deduplicateByUrl(gifs);
                if (uniqueGifs.length < 2) return uniqueGifs;

                const result = [];
                const remaining = [...uniqueGifs];
                const recentArtists = []; // Track last N artists to prevent clustering
                const recentTitles = []; // Track recent titles to avoid similar content

                while (remaining.length > 0) {
                    let bestIdx = 0;
                    let bestScore = -1;

                    // Find best next item (different from recent artists)
                    for (let i = 0; i < Math.min(remaining.length, 30); i++) {
                        const gif = remaining[i];
                        const artist = gif.username || 'Unknown';
                        const title = (gif.title || '').toLowerCase().substring(0, 20);

                        // Score based on how different this artist is from recent ones
                        let score = 10;
                        const artistIdx = recentArtists.indexOf(artist);
                        if (artistIdx === -1) {
                            score += 8; // Big bonus for new artist
                        } else {
                            score -= (8 - artistIdx); // Penalty based on how recent
                        }

                        // Penalty for similar titles
                        if (recentTitles.some(t => t === title || t.includes(title) || title.includes(t))) {
                            score -= 5;
                        }

                        if (score > bestScore) {
                            bestScore = score;
                            bestIdx = i;
                        }
                    }

                    const selected = remaining.splice(bestIdx, 1)[0];
                    const selectedArtist = selected.username || 'Unknown';
                    const selectedTitle = (selected.title || '').toLowerCase().substring(0, 20);

                    result.push(selected);

                    // Track recent artists (keep last 8)
                    recentArtists.unshift(selectedArtist);
                    if (recentArtists.length > 8) recentArtists.pop();

                    // Track recent titles (keep last 5)
                    recentTitles.unshift(selectedTitle);
                    if (recentTitles.length > 5) recentTitles.pop();
                }

                return result;
            }

            if (dopamineMode) {
                // Dopamine Rush: multiple rows scrolling in alternating directions
                container.classList.add('dopamine-mode');

                // Calculate how many items per row and how many rows to fill screen
                const itemsPerRow = Math.ceil(window.innerWidth / 200) + 2;
                const rowHeight = 176; // 170px row + 6px gap
                const numRows = Math.max(3, Math.ceil((window.innerHeight - 65) / rowHeight));

                // Smart shuffle gifs for variety (no adjacent duplicates, spread artists)
                const shuffled = smartShuffle([...displayGifs].sort(() => Math.random() - 0.5));

                // Split gifs into separate pools for each row (no overlap)
                const gifsPerRowPool = Math.floor(shuffled.length / numRows);

                let rowsHtml = '';
                for (let r = 0; r < numRows; r++) {
                    // Each row gets its own unique slice of gifs
                    const startIdx = r * gifsPerRowPool;
                    const rowPool = shuffled.slice(startIdx, startIdx + gifsPerRowPool);

                    // If pool is too small, we need to pad it
                    const minItems = itemsPerRow * 3;
                    const rowGifs = [];

                    // Fill row with unique items from this row's pool only
                    for (let i = 0; i < minItems; i++) {
                        rowGifs.push(rowPool[i % rowPool.length]);
                    }

                    rowsHtml += `
                        <div class="dopamine-row" id="dopRow${r}">
                            ${rowGifs.map((gif, i) => makeCard(gif, allGifs.indexOf(gif))).join('')}
                        </div>
                    `;
                }

                track.innerHTML = rowsHtml;
                track.style.display = ''; // CSS will handle flex column
            } else {
                // Normal single row mode
                container.classList.remove('dopamine-mode');
                track.style.display = ''; // Reset display style

                // Calculate how many cards fit in viewport + buffer for seamless loop
                const viewportCards = Math.ceil(window.innerWidth / (cardSize + 12)) + 4;
                const minCardsNeeded = viewportCards * 3; // 3x viewport for smooth seamless loop

                // Smart shuffle to prevent adjacent duplicates and spread artists
                const shuffled = smartShuffle([...displayGifs].sort(() => Math.random() - 0.5));

                // Only use as many gifs as needed, then duplicate for seamless loop
                const sourceGifs = shuffled.length > minCardsNeeded
                    ? shuffled.slice(0, minCardsNeeded)
                    : shuffled;

                // Double for seamless loop (but only the subset we need)
                const gifs = [...sourceGifs, ...sourceGifs];

                track.innerHTML = gifs.map((gif, i) => {
                    const idx = allGifs.indexOf(gif);
                    return makeCard(gif, idx >= 0 ? idx : i % sourceGifs.length);
                }).join('');

                console.log(`Non-dopamine mode: Rendering ${gifs.length} cards (${sourceGifs.length} unique) from ${displayGifs.length} available`);
            }
        }

        let currentFullscreenIndex = null;

        function openFullscreen(index) {
            currentFullscreenIndex = index;
            fullscreenOpen = true;
            mouseSpeed = 0;

            const gif = allGifs[index];
            const url = gif.images?.fixed_height?.url || gif.images?.original?.url;
            const artist = gif.username || 'Unknown artist';
            const isSaved = isBookmarked(gif.id);

            document.getElementById('fullscreenImg').src = url;
            document.getElementById('fullscreenTitle').textContent = gif.title || 'Untitled';
            document.getElementById('fullscreenArtist').textContent = `by ${artist} Â· ${gif.source || 'Unknown source'}`;

            // Display price and edition info (for NFTs)
            const priceEl = document.getElementById('fullscreenPrice');
            if (gif.source && gif.source.includes('objkt')) {
                const editionText = gif.editionDisplay ? ` Â· ${gif.editionDisplay}` : '';
                const oneOfOneClass = gif.isOneOfOne ? ' one-of-one' : '';
                if (gif.priceDisplay) {
                    priceEl.innerHTML = `${gif.priceDisplay}${editionText} Â· <span style="color:#00ff88;">Available</span>`;
                    priceEl.className = 'fullscreen-price' + oneOfOneClass;
                } else {
                    priceEl.innerHTML = `Sold Out / Not Listed${editionText}`;
                    priceEl.className = 'fullscreen-price sold-out' + oneOfOneClass;
                }
                priceEl.style.display = 'block';
            } else {
                priceEl.style.display = 'none';
            }

            // Display external link button (for NFTs and other external sources)
            const externalBtn = document.getElementById('fullscreenExternalBtn');
            if (gif.externalUrl) {
                externalBtn.href = gif.externalUrl;
                externalBtn.textContent = `â†— View on ${gif.source || 'External Site'}`;
                externalBtn.style.display = 'inline-block';
            } else {
                externalBtn.style.display = 'none';
            }

            // Display tags - clicking a tag adds it as a filter
            const tags = gif.tags || [];
            const tagsHtml = tags.length > 0
                ? tags.map(tag => `<span class="fullscreen-tag" onclick="addTagAsFilter('${tag}')">${tag}</span>`).join('')
                : '<span style="color:#666;font-size:0.75rem;">No tags available</span>';
            document.getElementById('fullscreenTags').innerHTML = tagsHtml;

            // Update save button
            const saveBtn = document.getElementById('fullscreenSaveBtn');
            saveBtn.style.display = 'inline-block';
            if (isSaved) {
                saveBtn.textContent = 'â˜… Saved';
                saveBtn.style.background = '#ff006e';
            } else {
                saveBtn.textContent = 'â˜† Save to Collection';
                saveBtn.style.background = '#8338ec';
            }

            document.getElementById('fullscreenModal').classList.add('active');
        }

        function addTagAsFilter(tag) {
            if (!allSearchTerms.includes(tag)) {
                allSearchTerms.push(tag);
            }
            if (!searchTerms.includes(tag)) {
                searchTerms.push(tag);
            }
            closeFullscreen();
            document.getElementById('filterPanel').classList.add('active');
            renderFilterTags();
        }

        function closeFullscreen() {
            document.getElementById('fullscreenModal').classList.remove('active');
            fullscreenOpen = false;
            currentFullscreenIndex = null;
        }

        function openSavedFullscreen(url, title) {
            fullscreenOpen = true;
            mouseSpeed = 0;
            document.getElementById('fullscreenImg').src = url;
            document.getElementById('fullscreenTitle').textContent = title || 'Saved artwork';
            document.getElementById('fullscreenArtist').textContent = '';
            document.getElementById('fullscreenTags').innerHTML = '<span style="color:#666;font-size:0.75rem;">Saved item</span>';
            document.getElementById('fullscreenSaveBtn').style.display = 'none';
            document.getElementById('fullscreenModal').classList.add('active');
        }

        function saveFromFullscreen() {
            if (currentFullscreenIndex === null) return;
            const gif = allGifs[currentFullscreenIndex];
            if (isBookmarked(gif.id)) {
                // Already saved - remove it
                savedArtworks = savedArtworks.filter(s => s.id !== gif.id);
                localStorage.setItem('savedGlitchArt', JSON.stringify(savedArtworks));
                updateSavedCount();
                renderGallery();
                openFullscreen(currentFullscreenIndex); // Refresh the modal
            } else {
                // Save it
                currentArtwork = gif;
                closeFullscreen();
                document.getElementById('saveModal').classList.add('active');
            }
        }

        function isBookmarked(id) {
            return savedArtworks.some(s => s.id === id);
        }

        function toggleBookmark(index) {
            currentArtwork = allGifs[index];
            if (isBookmarked(currentArtwork.id)) {
                savedArtworks = savedArtworks.filter(s => s.id !== currentArtwork.id);
                localStorage.setItem('savedGlitchArt', JSON.stringify(savedArtworks));
                updateSavedCount();
                renderGallery();
            } else {
                document.getElementById('saveModal').classList.add('active');
            }
        }

        function closeModal() {
            document.getElementById('saveModal').classList.remove('active');
            document.getElementById('tagInput').value = '';
            document.getElementById('noteInput').value = '';
        }

        function confirmSave() {
            const url = currentArtwork.images?.fixed_height?.url || currentArtwork.images?.original?.url;
            savedArtworks.push({
                id: currentArtwork.id,
                url: url,
                title: currentArtwork.title || 'Untitled',
                user: currentArtwork.username || currentArtwork.user?.username || 'Unknown',
                tags: document.getElementById('tagInput').value,
                note: document.getElementById('noteInput').value,
                savedAt: new Date().toISOString()
            });
            localStorage.setItem('savedGlitchArt', JSON.stringify(savedArtworks));
            updateSavedCount();
            closeModal();
            renderGallery();
        }

        function updateSavedCount() {
            document.getElementById('savedCount').textContent = savedArtworks.length;
        }

        function showGallery() {
            document.getElementById('galleryContainer').classList.remove('hidden');
            document.getElementById('savedSection').classList.remove('active');
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.nav-btn')[0].classList.add('active');
        }

        function showSaved() {
            document.getElementById('galleryContainer').classList.add('hidden');
            document.getElementById('savedSection').classList.add('active');
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.nav-btn')[1].classList.add('active');
            renderSaved();
        }

        function renderSaved() {
            const grid = document.getElementById('savedGrid');
            if (savedArtworks.length === 0) {
                grid.innerHTML = '<p style="color:#666;grid-column:1/-1;text-align:center;padding:40px;">No saved art yet. Click â˜† to save.</p>';
                return;
            }
            // Use DocumentFragment for better performance
            const fragment = document.createDocumentFragment();
            savedArtworks.forEach((art, i) => {
                const card = document.createElement('div');
                card.className = 'saved-card';
                card.innerHTML = `
                    <div class="art-media" onclick="openSavedFullscreen('${art.url}', '${art.title.replace(/'/g, "\\'")}')">
                        <img src="${art.url}" alt="${art.title}" loading="lazy" decoding="async">
                    </div>
                    <div class="art-info">
                        <div>${art.user} Â· ${art.title.substring(0, 25)}</div>
                        <input type="text" class="tag-input" value="${art.tags || ''}" placeholder="Tags..."
                               onchange="updateTags(${i}, this.value)">
                        <input type="text" class="tag-input" value="${art.note || ''}" placeholder="Note..."
                               onchange="updateNote(${i}, this.value)">
                        <button class="remove-btn" onclick="removeSaved(${i})">Remove</button>
                    </div>
                `;
                fragment.appendChild(card);
            });
            grid.innerHTML = '';
            grid.appendChild(fragment);
        }

        function updateTags(i, v) {
            savedArtworks[i].tags = v;
            localStorage.setItem('savedGlitchArt', JSON.stringify(savedArtworks));
        }
        function updateNote(i, v) {
            savedArtworks[i].note = v;
            localStorage.setItem('savedGlitchArt', JSON.stringify(savedArtworks));
        }
        function removeSaved(i) {
            savedArtworks.splice(i, 1);
            localStorage.setItem('savedGlitchArt', JSON.stringify(savedArtworks));
            updateSavedCount();
            renderSaved();
        }

        function exportCollection() {
            if (savedArtworks.length === 0) {
                alert('No saved items to export');
                return;
            }
            const data = JSON.stringify(savedArtworks, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'glitch-collection-' + new Date().toISOString().split('T')[0] + '.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function importCollection(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (Array.isArray(imported)) {
                        // Merge with existing, avoid duplicates by ID
                        const existingIds = new Set(savedArtworks.map(a => a.id));
                        let added = 0;
                        imported.forEach(item => {
                            if (!existingIds.has(item.id)) {
                                savedArtworks.push(item);
                                added++;
                            }
                        });
                        localStorage.setItem('savedGlitchArt', JSON.stringify(savedArtworks));
                        updateSavedCount();
                        renderSaved();
                        renderGallery();
                        alert(`Imported ${added} new items (${imported.length - added} duplicates skipped)`);
                    } else {
                        alert('Invalid format - expected array of saved items');
                    }
                } catch (err) {
                    alert('Error reading file: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }

        // Scroll system
        let fullscreenOpen = false;

        function setupScroll() {
            const track = document.getElementById('scrollTrack');

            // Only control scroll when hovering actual video cards
            track.addEventListener('mouseenter', () => { mouseControlled = true; });
            track.addEventListener('mouseleave', () => { mouseControlled = false; mouseSpeed = 0; });
            track.addEventListener('mousemove', (e) => {
                if (mouseControlled && !fullscreenOpen) {
                    const centerX = window.innerWidth / 2;
                    const deadZone = 150; // pixels from center = no movement
                    const dist = e.clientX - centerX;

                    // Dead zone in the middle
                    if (Math.abs(dist) < deadZone) {
                        mouseSpeed = 0;
                    } else {
                        // Inverted: mouse left pulls content right (towards you), mouse right pulls left
                        const adjustedDist = dist > 0 ? dist - deadZone : dist + deadZone;
                        mouseSpeed = -(adjustedDist / ((window.innerWidth / 2) - deadZone)) * 12;
                    }
                }
            });

            // Touch support for mobile
            let touchStartX = 0;
            let touchStartY = 0;
            let isSwiping = false;

            track.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                isSwiping = true;
                mouseControlled = true;
            }, { passive: true });

            track.addEventListener('touchmove', (e) => {
                if (!isSwiping || fullscreenOpen) return;

                const touchX = e.touches[0].clientX;
                const touchY = e.touches[0].clientY;
                const deltaX = touchX - touchStartX;
                const deltaY = touchY - touchStartY;

                // Only control horizontal scroll if mostly horizontal swipe
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // Swipe right = positive deltaX = scroll left (content moves right)
                    // Swipe left = negative deltaX = scroll right (content moves left)
                    mouseSpeed = deltaX * 0.15;
                }

                touchStartX = touchX;
                touchStartY = touchY;
            }, { passive: true });

            track.addEventListener('touchend', () => {
                isSwiping = false;
                mouseControlled = false;
                mouseSpeed = 0;
            }, { passive: true });

            function animate() {
                // Cache track reference
                if (!animCachedTrack) animCachedTrack = document.getElementById('scrollTrack');
                if (!animCachedTrack || allGifs.length === 0) {
                    requestAnimationFrame(animate);
                    return;
                }

                // Pause scrolling when fullscreen is open
                if (!fullscreenOpen) {
                    if (dopamineMode) {
                        // Dopamine Rush: alternating rows scrolling left/right
                        const rowHeight = 176; // 170px row + 6px gap
                        const numRows = Math.max(3, Math.ceil((window.innerHeight - 65) / rowHeight));

                        // Re-cache rows if count changed (new rows added)
                        if (numRows !== animLastRowCount) {
                            animCachedRows = [];
                            for (let r = 0; r < numRows; r++) {
                                animCachedRows[r] = document.getElementById('dopRow' + r);
                            }
                            animLastRowCount = numRows;
                        }

                        const baseSpeed = Math.abs(autoSpeed) * 1.5;

                        for (let r = 0; r < numRows; r++) {
                            const row = animCachedRows[r];
                            if (row) {
                                const maxScroll = row.scrollWidth / 3;

                                // Initialize position if needed
                                if (rowScrollPos[r] === undefined) rowScrollPos[r] = 0;

                                // Alternate direction: even rows go right (positive), odd rows go left (negative)
                                const direction = r % 2 === 0 ? 1 : -1;
                                // Vary speed slightly per row
                                const speed = baseSpeed * (0.8 + (r % 3) * 0.2);

                                rowScrollPos[r] += speed * direction;

                                // Wrap around
                                if (rowScrollPos[r] > 0) rowScrollPos[r] = -maxScroll;
                                if (rowScrollPos[r] < -maxScroll) rowScrollPos[r] = 0;

                                // Use translate3d for GPU acceleration
                                row.style.transform = `translate3d(${rowScrollPos[r]}px, 0, 0)`;
                            }
                        }
                    } else {
                        // Normal single row mode
                        const maxScroll = animCachedTrack.scrollWidth / 2;
                        const speed = mouseControlled ? mouseSpeed : autoSpeed;

                        scrollPos += speed;
                        if (scrollPos > 0) scrollPos = -maxScroll;
                        if (scrollPos < -maxScroll) scrollPos = 0;

                        // Use translate3d for GPU acceleration
                        animCachedTrack.style.transform = `translate3d(${scrollPos}px, 0, 0)`;
                    }
                }
                requestAnimationFrame(animate);
            }
            animate();
        }

        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                closeFullscreen();
                closeModal();
                closePanels();
            }
        });

        // Click outside to close panels
        document.addEventListener('click', e => {
            const filterPanel = document.getElementById('filterPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            const filterBtns = document.querySelectorAll('.filter-toggle');

            // Check if click is outside filter panel
            if (filterPanel.classList.contains('active')) {
                if (!filterPanel.contains(e.target) && !filterBtns[0].contains(e.target)) {
                    filterPanel.classList.remove('active');
                    filterBtns[0].classList.remove('active');
                }
            }

            // Check if click is outside settings panel
            if (settingsPanel.classList.contains('active')) {
                if (!settingsPanel.contains(e.target) && !filterBtns[1].contains(e.target)) {
                    settingsPanel.classList.remove('active');
                    filterBtns[1].classList.remove('active');
                }
            }
        });

        // Helper to close all panels and clear button states
        function closePanels() {
            document.getElementById('filterPanel').classList.remove('active');
            document.getElementById('settingsPanel').classList.remove('active');
            document.querySelectorAll('.filter-toggle').forEach(btn => btn.classList.remove('active'));
        }

        // Filter system
        function toggleFilters() {
            const filterPanel = document.getElementById('filterPanel');
            const isOpening = !filterPanel.classList.contains('active');

            filterPanel.classList.toggle('active');
            document.getElementById('settingsPanel').classList.remove('active');

            // Update button states
            const filterBtns = document.querySelectorAll('.filter-toggle');
            filterBtns[0].classList.toggle('active', isOpening); // Filters button
            filterBtns[1].classList.remove('active'); // Settings button

            renderFilterTags();
        }

        // Track which categories are expanded
        const expandedCategories = new Set();

        function renderFilterTags() {
            // Render active filters
            const activeContainer = document.getElementById('activeFilters');
            const countSpan = document.getElementById('activeFilterCount');

            if (searchTerms.length === 0) {
                activeContainer.innerHTML = '<span style="color:#666;font-size:0.8rem;">No filters - showing all art</span>';
                countSpan.textContent = '';
            } else {
                activeContainer.innerHTML = searchTerms.map(term => `
                    <span class="filter-tag active" onclick="event.stopPropagation(); toggleFilter('${term.replace(/'/g, "\\'")}')" style="cursor:pointer;">
                        ${term} <span style="margin-left:5px;color:#ff6464;">&times;</span>
                    </span>
                `).join('');
                countSpan.textContent = `(${searchTerms.length} active)`;
            }

            // Render collapsible categories
            const categoriesContainer = document.getElementById('filterCategories');
            categoriesContainer.innerHTML = Object.entries(filterCategories).map(([key, category]) => {
                const isExpanded = expandedCategories.has(key);
                const activeInCategory = category.terms.filter(t => searchTerms.includes(t)).length;
                return `
                    <div class="filter-category" style="margin-bottom:8px;">
                        <div onclick="event.stopPropagation(); toggleCategoryExpand('${key}')" style="cursor:pointer;padding:8px 12px;background:rgba(255,255,255,0.05);border-radius:6px;display:flex;justify-content:space-between;align-items:center;border-left:3px solid ${category.color};">
                            <span style="font-weight:bold;color:${category.color};">${category.name}</span>
                            <span style="display:flex;align-items:center;gap:10px;">
                                ${activeInCategory > 0 ? `<span style="background:${category.color};color:#fff;padding:2px 8px;border-radius:10px;font-size:0.7rem;">${activeInCategory}</span>` : ''}
                                <span style="color:#888;">${isExpanded ? 'â–¼' : 'â–¶'}</span>
                            </span>
                        </div>
                        ${isExpanded ? `
                            <div style="padding:10px;background:rgba(0,0,0,0.3);border-radius:0 0 6px 6px;display:flex;flex-wrap:wrap;gap:6px;">
                                <button class="preset-btn" style="background:${category.color};font-size:0.7rem;padding:4px 8px;" onclick="event.stopPropagation();applyCategoryPreset('${key}')">Select All</button>
                                ${category.terms.map(term => `
                                    <span class="filter-tag ${searchTerms.includes(term) ? 'active' : ''}"
                                          onclick="event.stopPropagation();toggleFilter('${term.replace(/'/g, "\\'")}')"
                                          style="font-size:0.75rem;padding:4px 8px;">${term}</span>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');

            // Easter egg filter - subtle, at the very end
            categoriesContainer.innerHTML += `
                <div style="margin-top:20px;text-align:right;">
                    <span class="filter-tag easter-egg-filter" onclick="clickEasterEgg()" title="...">easter egg</span>
                </div>
            `;

            // Update filter count (old location for backward compat)
            const filterCount = document.getElementById('filterCount');
            if (filterCount) {
                filterCount.textContent = searchTerms.length === 0 ? 'Random art mode' : `${searchTerms.length} filters`;
            }
        }

        function toggleCategoryExpand(categoryKey) {
            if (expandedCategories.has(categoryKey)) {
                expandedCategories.delete(categoryKey);
            } else {
                expandedCategories.add(categoryKey);
            }
            renderFilterTags();
        }

        function toggleFilter(term) {
            if (searchTerms.includes(term)) {
                searchTerms = searchTerms.filter(t => t !== term);
            } else {
                searchTerms.push(term);
            }
            renderFilterTags();
            updatePendingChangesIndicator(); // No auto-reload
        }

        function applyPreset(preset) {
            searchTerms = [...presets[preset]];
            renderFilterTags();
            applyFilters(); // Presets auto-apply
        }

        function clearAllFilters() {
            searchTerms = [];
            activePreset = 'all';
            renderFilterTags();
            renderArtWheel();
            closeFilterPanel();
            applyFilters(); // Random art auto-applies
        }

        // Track which preset is currently active
        let activePreset = 'all'; // 'all' means no filters (random art)

        // Subreddit mappings for each category preset
        const categorySubreddits = {
            glitch: ['glitch_art', 'VaporwaveAesthetics', 'pixelsorting', 'brokengifs', 'gonwild'],
            traditional: ['Art', 'museum', 'ArtPorn', 'Illustration'],
            digital: ['DigitalArt', 'ImaginaryLandscapes', 'ImaginaryCharacters', 'Cyberpunk'],
            pixel: ['PixelArt', 'outrun'],
            animation: ['animation', 'HighQualityGifs', 'Cinemagraphs', 'SplitDepthGIFS', 'loadingicon', 'perfectloops'],
            threeD: ['generative', 'proceduralgeneration'],
            ai: ['generative'],
            nft: [],
            photography: ['ExposurePorn', 'LongExposurePics', 'itookapicture', 'photocritique'],
            aesthetic: ['VaporwaveAesthetics', 'outrun', 'Cyberpunk', 'currentlytripping', 'woahdude', 'trippy'],
            abstract: ['AbstractArt', 'generative', 'PlotterArt', 'proceduralgeneration'],
            webNostalgia: ['vintagecomputing', 'retrobattlestations', 'nostalgia', 'oldweb', 'internetarchive', 'retrowebdev'],
            anime: ['anime', 'Animewallpaper', 'AnimeART', 'wholesomeanimemes', 'animegifs', 'Moescape', 'AnimeSketch', 'ImaginarySliceOfLife'],
            nostalgia: ['nostalgia', 'OldSchoolCool', 'retrogaming', 'VintageApple', 'vintagecomputing', '90s', '80s', 'retrobattlestations', 'cassetteculture']
        };

        // Apply a category preset from the Art Wheel
        function applyCategoryPreset(categoryKey) {
            const category = filterCategories[categoryKey];
            if (!category) return;
            searchTerms = [...category.terms];
            activePreset = categoryKey;
            // Set relevant subreddits for this category
            redditSubs = categorySubreddits[categoryKey] ? [...categorySubreddits[categoryKey]] : [];
            renderFilterTags();
            renderRedditTags();
            renderArtWheel();
            // Close filter panel when selecting from Art Wheel
            closeFilterPanel();
            applyFilters();
        }

        // Close filter panel helper
        function closeFilterPanel() {
            const panel = document.getElementById('filterPanel');
            if (panel && panel.classList.contains('active')) {
                panel.classList.remove('active');
                // Also clear button state
                const filterBtns = document.querySelectorAll('.filter-toggle');
                if (filterBtns[0]) filterBtns[0].classList.remove('active');
            }
        }

        // Render the Art Wheel with active state
        function renderArtWheel() {
            const container = document.getElementById('artWheelContainer');
            const indicator = document.getElementById('activePresetIndicator');
            if (!container) return;

            const presetButtons = [
                { key: 'all', name: 'ALL ART', color: '#8338ec', textColor: '#fff' },
                { key: 'glitch', name: 'Glitch', color: filterCategories.glitch.color, textColor: '#fff' },
                { key: 'traditional', name: 'Traditional', color: filterCategories.traditional.color, textColor: '#fff' },
                { key: 'digital', name: 'Digital', color: filterCategories.digital.color, textColor: '#fff' },
                { key: 'pixel', name: 'Pixel', color: filterCategories.pixel.color, textColor: '#000' },
                { key: 'animation', name: 'Animation', color: filterCategories.animation.color, textColor: '#fff' },
                { key: 'threeD', name: '3D/Blender', color: filterCategories.threeD.color, textColor: '#fff' },
                { key: 'ai', name: 'AI Art', color: filterCategories.ai.color, textColor: '#fff' },
                { key: 'nft', name: 'NFT', color: filterCategories.nft.color, textColor: '#fff' },
                { key: 'photography', name: 'Photo', color: filterCategories.photography.color, textColor: '#fff' },
                { key: 'aesthetic', name: 'Aesthetic', color: filterCategories.aesthetic.color, textColor: '#fff' },
                { key: 'abstract', name: 'Abstract', color: filterCategories.abstract.color, textColor: '#fff' },
                { key: 'webNostalgia', name: 'Web Nostalgia', color: filterCategories.webNostalgia.color, textColor: '#000' },
                { key: 'anime', name: 'Anime', color: filterCategories.anime.color, textColor: '#fff' },
                { key: 'nostalgia', name: 'Nostalgia', color: filterCategories.nostalgia.color, textColor: '#fff' },
                { key: 'publicDomain', name: 'Public Domain', color: '#333', textColor: '#fff' }
            ];

            container.innerHTML = presetButtons.map(btn => {
                const isActive = activePreset === btn.key;
                // Active: full color with glow. Inactive: muted gray with subtle border
                const activeStyle = isActive
                    ? `background:${btn.color};color:${btn.textColor};box-shadow:0 0 15px ${btn.color},inset 0 0 0 2px #fff;transform:scale(1.05);`
                    : `background:rgba(50,50,50,0.8);color:#888;border:1px solid rgba(255,255,255,0.2);`;
                const clickHandler = btn.key === 'all' ? 'clearAllFilters()' :
                                     btn.key === 'publicDomain' ? 'applyPublicDomain()' :
                                     `applyCategoryPreset('${btn.key}')`;
                return `<button class="preset-btn" style="${activeStyle}" onclick="${clickHandler}">${btn.name}${isActive ? ' âœ“' : ''}</button>`;
            }).join('');

            // Update indicator
            if (indicator) {
                if (activePreset === 'all') {
                    indicator.textContent = '(Random mode - all art types)';
                } else {
                    const cat = filterCategories[activePreset];
                    indicator.textContent = cat ? `(${cat.name} mode)` : '';
                }
            }
        }

        // objkt.com artist filter functions
        function setObjktArtist() {
            const input = document.getElementById('objktArtistInput');
            const status = document.getElementById('objktArtistStatus');
            const value = input.value.trim();

            if (value) {
                objktArtistHandle = value;
                status.textContent = `Filtering by: ${value}`;
                status.style.color = '#ff006e';
                // Enable objkt source if not already
                sourcesEnabled.objkt = true;
                renderSourceToggles();
                applyFilters(); // Apply immediately for objkt artist search
            } else {
                status.textContent = 'Enter a wallet address or alias';
                status.style.color = '#888';
            }
        }

        function clearObjktArtist() {
            const input = document.getElementById('objktArtistInput');
            const status = document.getElementById('objktArtistStatus');
            objktArtistHandle = '';
            input.value = '';
            status.textContent = 'Cleared - showing all artists';
            status.style.color = '#8338ec';
            applyFilters(); // Apply immediately
        }

        // GLITCH ONLY preset - turns off non-glitch sources, applies glitch filters
        function applyGlitchOnly() {
            // Turn off general/stock sources
            sourcesEnabled.pexels = false;
            sourcesEnabled.pixabay = false;
            sourcesEnabled.nasa = false;
            sourcesEnabled.wikipedia = false;
            sourcesEnabled.archive = false;
            // Keep glitch-friendly sources on
            sourcesEnabled.tenor = true;
            sourcesEnabled.giphy = true;
            sourcesEnabled.reddit = true;
            sourcesEnabled.objkt = true;
            sourcesEnabled.deviantart = true;
            sourcesEnabled.tumblr = true;
            sourcesEnabled.bluesky = true;
            // Apply glitch filters
            searchTerms = [...presets.glitch];
            // Update UI
            renderSourceToggles();
            renderSourceControls();
            renderFilterTags();
            applyFilters(); // Preset auto-applies
        }

        // Public Domain preset - NASA, Wikipedia, Archive, Pixabay only
        function applyPublicDomain() {
            // Turn off non-public-domain sources
            Object.keys(sourcesEnabled).forEach(s => sourcesEnabled[s] = false);
            // Enable public domain sources
            sourcesEnabled.nasa = true;
            sourcesEnabled.wikipedia = true;
            sourcesEnabled.archive = true;
            sourcesEnabled.pexels = true; // Pexels is free to use
            // Clear filters for general content
            searchTerms = [];
            activePreset = 'publicDomain';
            // Update UI
            renderSourceToggles();
            renderSourceControls();
            renderFilterTags();
            renderArtWheel();
            closeFilterPanel();
            applyFilters(); // Preset auto-applies
        }

        const sourceNames = {
            tenor: 'Tenor', giphy: 'Giphy', reddit: 'Reddit', tumblr: 'Tumblr',
            bluesky: 'Bluesky', deviantart: 'DeviantArt', archive: 'Archive.org',
            wikipedia: 'Wikipedia', objkt: 'objkt', exchange: 'Exchange.art',
            mallow: 'mallow.art', foster: 'Foster', pexels: 'Pexels',
            pixabay: 'Pixabay', nasa: 'NASA'
        };

        // Sources that are not yet available (no public API or needs setup)
        const comingSoonSources = ['exchange', 'mallow', 'foster', 'pixabay'];

        function renderSourceToggles() {
            const container = document.getElementById('sourceToggles');
            container.innerHTML = Object.keys(sourcesEnabled).map(source => {
                const isComingSoon = comingSoonSources.includes(source);
                if (isComingSoon) {
                    return `<span class="filter-tag coming-soon" title="Coming Soon - API integration in progress">${sourceNames[source]} <small>(Soon)</small></span>`;
                }
                return `<span class="filter-tag ${sourcesEnabled[source] ? 'active' : ''}" onclick="event.stopPropagation(); toggleSource('${source}')">${sourceNames[source]}</span>`;
            }).join('');

            // Easter egg step 3: Show secret source when secret sub is found
            if (easterEggState.secretSubFound) {
                container.innerHTML += `
                    <span class="filter-tag secret-reveal" onclick="clickSecretSource()"
                          style="background:rgba(0,255,0,0.1);border-color:#00ff00;color:#00ff00;margin-left:10px;">
                        ðŸ¤« shhhh
                    </span>
                `;
            }
        }

        function renderSourceControls() {
            const container = document.getElementById('sourceControls');
            container.innerHTML = Object.keys(sourcesEnabled).map(source => {
                const isComingSoon = comingSoonSources.includes(source);
                if (isComingSoon) {
                    return `<div class="source-control coming-soon" id="ctrl_${source}">
                        <span class="source-name" style="color:#666;">${sourceNames[source]} <small>(Coming Soon)</small></span>
                        <input type="range" class="source-weight" min="0" max="3" step="0.5" value="0" disabled style="opacity:0.3;">
                        <span class="weight-val" style="color:#666;">--</span>
                    </div>`;
                }
                return `<div class="source-control ${sourcesEnabled[source] ? '' : 'disabled'}" id="ctrl_${source}">
                    <span class="source-name ${sourcesEnabled[source] ? '' : 'off'}">${sourceNames[source]}</span>
                    <input type="range" class="source-weight" min="0" max="3" step="0.5" value="${sourceWeights[source]}"
                           oninput="updateWeight('${source}', this.value)">
                    <span class="weight-val" id="weight_${source}">${sourceWeights[source]}x</span>
                </div>`;
            }).join('');
        }

        let reloadTimeout = null;

        function scheduleReload(delay = 500) {
            clearTimeout(reloadTimeout);
            const indicator = document.getElementById('reloadIndicator');
            if (indicator) indicator.style.display = 'inline';
            reloadTimeout = setTimeout(() => {
                if (indicator) indicator.style.display = 'none';
                applyFilters();
            }, delay);
        }

        function toggleSource(source) {
            // Check if this would disable ALL sources
            const wouldBeEnabled = {...sourcesEnabled, [source]: !sourcesEnabled[source]};
            const anyEnabled = Object.values(wouldBeEnabled).some(v => v);

            if (!anyEnabled) {
                // Don't allow disabling all sources
                alert('At least one source must be enabled!');
                return;
            }

            sourcesEnabled[source] = !sourcesEnabled[source];
            renderSourceToggles();
            renderSourceControls();
            updatePendingChangesIndicator();
            // No auto-reload - user must click Apply Changes
        }

        function updatePendingChangesIndicator() {
            const indicator = document.getElementById('pendingChanges');
            if (indicator) indicator.style.display = 'inline';
        }

        function hidePendingChangesIndicator() {
            const indicator = document.getElementById('pendingChanges');
            if (indicator) indicator.style.display = 'none';
        }

        function toggleSettings() {
            const settingsPanel = document.getElementById('settingsPanel');
            const isOpening = !settingsPanel.classList.contains('active');

            settingsPanel.classList.toggle('active');
            document.getElementById('filterPanel').classList.remove('active');

            // Update button states
            const filterBtns = document.querySelectorAll('.filter-toggle');
            filterBtns[0].classList.remove('active'); // Filters button
            filterBtns[1].classList.toggle('active', isOpening); // Settings button
        }

        function updateScrollSpeed(value) {
            autoSpeed = -parseFloat(value);
            document.getElementById('scrollSpeedVal').textContent = value + 'x';
        }

        function updateCardSize(value) {
            cardSize = parseInt(value);
            document.getElementById('cardSizeVal').textContent = value + 'px';
            renderGallery(); // Auto-apply
        }

        // Seizure Safe Mode - reduces flashing, shows static images, filters strobe content
        function toggleSeizureSafe() {
            seizureSafeMode = !seizureSafeMode;
            localStorage.setItem('seizureSafeMode', seizureSafeMode);
            applySeizureSafeMode();
            // Re-render to apply static images and filter flash content
            renderGallery();
        }

        function applySeizureSafeMode() {
            const btn = document.getElementById('seizureSafeBtn');
            if (seizureSafeMode) {
                document.body.classList.add('seizure-safe-mode');
                btn.classList.add('active');
                btn.textContent = 'SEIZURE SAFE: ON';
                btn.style.background = '#2ecc71';
            } else {
                document.body.classList.remove('seizure-safe-mode');
                btn.classList.remove('active');
                btn.textContent = 'SEIZURE SAFE: OFF';
                btn.style.background = '#333';
            }
        }

        // Check if content has flash-related tags
        function hasFlashTags(tags) {
            if (!tags || !Array.isArray(tags)) return false;
            const lowerTags = tags.map(t => (t || '').toString().toLowerCase());
            return FLASH_TAGS.some(flashTag =>
                lowerTags.some(tag => tag.includes(flashTag))
            );
        }

        // Check title for flash-related words
        function hasFlashTitle(title) {
            if (!title) return false;
            const lowerTitle = title.toLowerCase();
            return FLASH_TAGS.some(flashTag => lowerTitle.includes(flashTag));
        }

        // SFW/NSFW Mode - filters adult content
        function toggleSfwMode() {
            // If switching TO NSFW mode, show confirmation
            if (sfwMode) {
                showNsfwConfirmation();
            } else {
                // Switching back to SFW - no confirmation needed
                sfwMode = true;
                localStorage.setItem('sfwMode', 'true');
                applySfwMode();
                applyFilters();
            }
        }

        function showNsfwConfirmation() {
            const modal = document.createElement('div');
            modal.id = 'nsfwConfirmModal';
            modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.9);z-index:5000;display:flex;justify-content:center;align-items:center;';
            modal.innerHTML = `
                <div style="background:#1a1a1a;border:2px solid #ff6464;border-radius:12px;padding:30px;max-width:400px;text-align:center;">
                    <h3 style="color:#ff6464;margin-bottom:15px;font-size:1.3rem;">NSFW Content Warning</h3>
                    <p style="color:#ccc;margin-bottom:20px;line-height:1.6;">
                        Enabling NSFW mode may show content containing:<br>
                        <strong style="color:#fff;">nudity, adult themes, and explicit material</strong>
                    </p>
                    <p style="color:#888;margin-bottom:25px;font-size:0.85rem;">
                        You must be 18+ years old to view this content.
                    </p>
                    <div style="display:flex;gap:15px;justify-content:center;">
                        <button onclick="confirmNsfw()" style="background:#ff6464;color:#fff;border:none;padding:12px 25px;border-radius:8px;cursor:pointer;font-size:1rem;">
                            I'm 18+, Continue
                        </button>
                        <button onclick="cancelNsfw()" style="background:#333;color:#fff;border:1px solid #555;padding:12px 25px;border-radius:8px;cursor:pointer;font-size:1rem;">
                            Stay in SFW
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function confirmNsfw() {
            const modal = document.getElementById('nsfwConfirmModal');
            if (modal) modal.remove();
            sfwMode = false;
            localStorage.setItem('sfwMode', 'false');
            applySfwMode();
            applyFilters();
        }

        function cancelNsfw() {
            const modal = document.getElementById('nsfwConfirmModal');
            if (modal) modal.remove();
            // Stay in SFW mode - don't change anything
        }

        function applySfwMode() {
            const btn = document.getElementById('sfwBtn');
            if (sfwMode) {
                btn.classList.add('sfw-active');
                btn.classList.remove('nsfw-active');
                btn.textContent = 'SFW: ON';
                btn.title = 'Safe For Work mode - click for NSFW (18+)';
                btn.style.background = '#3a86ff';
                btn.style.color = '#fff';
            } else {
                btn.classList.remove('sfw-active');
                btn.classList.add('nsfw-active');
                btn.textContent = 'NSFW: ON';
                btn.title = 'NSFW mode - adult content visible. Click for SFW';
                btn.style.background = '#ff6464';
                btn.style.color = '#fff';
            }
        }

        // Check if content has NSFW tags
        function hasNsfwTags(tags) {
            if (!tags || !Array.isArray(tags)) return false;
            const lowerTags = tags.map(t => (t || '').toString().toLowerCase());
            return NSFW_TAGS.some(nsfwTag =>
                lowerTags.some(tag => tag.includes(nsfwTag))
            );
        }

        // Check title for NSFW words
        function hasNsfwTitle(title) {
            if (!title) return false;
            const lowerTitle = title.toLowerCase();
            return NSFW_TAGS.some(nsfwTag => lowerTitle.includes(nsfwTag));
        }

        async function toggleDopamineMode() {
            dopamineMode = !dopamineMode;
            const btn = document.getElementById('dopamineBtn');
            const track = document.getElementById('scrollTrack');

            // Clear animation cache when toggling mode
            animCachedRows = [];
            animLastRowCount = 0;
            animCachedTrack = null;

            if (dopamineMode) {
                btn.style.background = '#ff006e';
                btn.textContent = 'DOPAMINE RUSH (ON)';

                // Check if we have GIF-compatible sources for dopamine refresh
                const hasGifSources = sourcesEnabled.tenor || sourcesEnabled.giphy;

                // Show loading screen for dopamine mode initial load
                if (allGifs.length < 100 && hasGifSources) {
                    resetLoadingProgress();
                    showLoading(true, 'ACTIVATING DOPAMINE RUSH...');
                    updateLoadingProgress(10);

                    // Load more content for dopamine mode
                    await loadMoreForDopamineWithProgress();

                    showLoading(false);
                } else if (allGifs.length < 10) {
                    // Not enough content and no GIF sources - show message
                    console.log('Dopamine mode: Using existing content (no GIF sources enabled for refresh)');
                }

                // Only start auto-refresh if we have GIF sources
                if (hasGifSources) {
                    dopamineRefreshInterval = setInterval(() => {
                        console.log('Dopamine refresh: loading new content...');
                        loadMoreForDopamine();
                    }, 30000);
                }
            } else {
                btn.style.background = '#333';
                btn.textContent = 'DOPAMINE RUSH';
                // Stop auto-refresh
                if (dopamineRefreshInterval) {
                    clearInterval(dopamineRefreshInterval);
                    dopamineRefreshInterval = null;
                }
                // Reset track display and transform when exiting dopamine mode
                if (track) {
                    track.style.display = '';
                    track.style.transform = '';
                }
            }
            // Reset all scroll positions
            rowScrollPos = [];
            scrollPos = 0;
            renderGallery(); // Auto-apply
        }

        // Load more content for dopamine mode without full reload
        async function loadMoreForDopamine() {
            if (!dopamineMode) return;

            const oldCount = allGifs.length;

            // Fetch from a few random sources to add variety
            const quickFetches = [];

            // Random Tenor searches (multiple terms for more variety)
            if (sourcesEnabled.tenor) {
                const randomTerms = ['art', 'loop', 'trippy', 'neon', 'abstract', 'psychedelic', 'weird', 'crazy', 'glitch', 'aesthetic', 'surreal', 'hypnotic'];
                // Fetch 2 different random terms
                for (let i = 0; i < 2; i++) {
                    const term = randomTerms[Math.floor(Math.random() * randomTerms.length)];
                    quickFetches.push(
                        fetch(`https://tenor.googleapis.com/v2/search?q=${term}&key=${TENOR_KEY}&limit=40&media_filter=gif&pos=${Math.floor(Math.random() * 200)}`)
                            .then(r => r.json())
                            .catch(() => ({ results: [] }))
                    );
                }
            }

            // Random Giphy searches (multiple terms for more variety)
            if (sourcesEnabled.giphy) {
                const randomTerms = ['glitch', 'abstract', 'trippy', 'neon', 'retro', 'vaporwave', 'pixel', 'loop', 'animation', 'art', 'digital', 'psychedelic'];
                // Fetch 2 different random terms
                for (let i = 0; i < 2; i++) {
                    const term = randomTerms[Math.floor(Math.random() * randomTerms.length)];
                    quickFetches.push(
                        fetch(`https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_KEY}&q=${term}&limit=40&offset=${Math.floor(Math.random() * 200)}&rating=${sfwMode ? 'pg-13' : 'r'}`)
                            .then(r => r.json())
                            .catch(() => ({ data: [] }))
                    );
                }
            }

            const results = await Promise.all(quickFetches);

            // Process and add new gifs using Set for O(1) dedup
            results.forEach(data => {
                if (data.results) {
                    // Tenor
                    data.results.forEach(item => {
                        const baseId = 'tenor_' + item.id;
                        if (!gifIdSet.has(baseId)) {
                            gifIdSet.add(baseId);
                            allGifs.push({
                                id: baseId + '_' + Date.now(),
                                title: item.content_description || 'Untitled',
                                username: item.itemurl ? new URL(item.itemurl).pathname.split('/')[1] : 'Unknown',
                                tags: item.tags || [],
                                source: 'Tenor',
                                images: {
                                    fixed_height: { url: item.media_formats?.gif?.url || item.media_formats?.tinygif?.url },
                                    original: { url: item.media_formats?.gif?.url }
                                }
                            });
                        }
                    });
                }
                if (data.data && Array.isArray(data.data)) {
                    // Giphy
                    data.data.forEach(item => {
                        const baseId = 'giphy_' + item.id;
                        if (!gifIdSet.has(baseId)) {
                            gifIdSet.add(baseId);
                            allGifs.push({
                                id: baseId + '_' + Date.now(),
                                title: item.title || 'Untitled',
                                username: item.username || item.user?.username || 'Unknown',
                                tags: item.tags || [],
                                source: 'Giphy',
                                images: {
                                    fixed_height: { url: item.images?.fixed_height?.url },
                                    original: { url: item.images?.original?.url }
                                }
                            });
                        }
                    });
                }
            });

            // Cap array size to prevent memory bloat
            if (allGifs.length > MAX_GIFS) {
                const removed = allGifs.splice(0, allGifs.length - MAX_GIFS);
                removed.forEach(g => {
                    const baseId = g.id.split('_').slice(0, 2).join('_');
                    gifIdSet.delete(baseId);
                });
            }

            // Shuffle to mix new content in
            allGifs.sort(() => Math.random() - 0.5);

            console.log(`Added ${allGifs.length - oldCount} new items, total: ${allGifs.length} (capped at ${MAX_GIFS})`);

            // Seamlessly add new content to existing rows instead of full re-render
            if (dopamineMode) {
                appendToDopamineRows();
            }
        }

        // Seamlessly append new cards to dopamine mode rows without clearing view
        function appendToDopamineRows() {
            const numRows = document.querySelectorAll('.dopamine-row').length;
            if (numRows === 0) {
                // First time or rows don't exist, do full render
                renderGallery();
                return;
            }

            // Shuffle new content
            const shuffled = [...allGifs].sort(() => Math.random() - 0.5);
            const gifsPerRowPool = Math.floor(shuffled.length / numRows);
            const itemsToAdd = 15; // Add this many per row

            for (let r = 0; r < numRows; r++) {
                const row = document.getElementById(`dopRow${r}`);
                if (!row) continue;

                // Get unique pool for this row
                const startIdx = r * gifsPerRowPool;
                const rowPool = shuffled.slice(startIdx, startIdx + gifsPerRowPool);

                // Create new cards from random items in the pool
                let newCardsHtml = '';
                for (let i = 0; i < itemsToAdd; i++) {
                    const gif = rowPool[Math.floor(Math.random() * rowPool.length)];
                    const idx = allGifs.indexOf(gif);
                    const url = gif.images?.fixed_height?.url || gif.images?.original?.url;
                    const title = gif.title || 'Untitled';
                    const user = gif.username || gif.user?.username || 'Unknown';
                    const source = gif.source || '';
                    const tags = gif.tags || [];
                    const firstTag = tags.length > 0 ? tags[0] : '';

                    newCardsHtml += `
                        <div class="art-card" style="width:${cardSize}px;" onclick="openFullscreen(${idx})">
                            <div class="art-media" style="height:${cardSize}px;">
                                <img src="${url}" alt="${title}" loading="lazy" decoding="async">
                            </div>
                            <button class="bookmark-btn ${isBookmarked(gif.id) ? 'saved' : ''}"
                                    onclick="event.stopPropagation(); toggleBookmark(${idx})">
                                ${isBookmarked(gif.id) ? 'â˜…' : 'â˜†'}
                            </button>
                            <div class="art-info">
                                <div><span style="color:#8338ec;">${source}</span></div>
                                <div style="color:#fff;">${user}</div>
                                ${firstTag ? `<div style="color:#3a86ff;font-size:0.7rem;">#${firstTag}</div>` : ''}
                            </div>
                        </div>
                    `;
                }

                // Append to end of row
                row.insertAdjacentHTML('beforeend', newCardsHtml);
            }

            // Update duplicate timing estimate
            updateDuplicateTiming();
        }

        // Calculate and display when user might see duplicates
        function updateDuplicateTiming() {
            const numRows = document.querySelectorAll('.dopamine-row').length;
            if (numRows === 0) return;

            // Get first row to calculate
            const firstRow = document.getElementById('dopRow0');
            if (!firstRow) return;

            const cardsInRow = firstRow.querySelectorAll('.art-card').length;
            const avgCardWidth = cardSize + 12; // Include gap
            const rowWidth = cardsInRow * avgCardWidth;
            const viewportWidth = window.innerWidth;

            // Speed is roughly autoSpeed * 60 (frames per sec) pixels per second
            const pixelsPerSecond = autoSpeed * 60;

            // Time to scroll through all cards before seeing duplicates
            const secondsUntilLoop = rowWidth / pixelsPerSecond;
            const minutesUntilLoop = Math.floor(secondsUntilLoop / 60);

            // Display estimate in console (could add UI indicator if desired)
            console.log(`Dopamine mode: ~${cardsInRow} cards per row, ~${minutesUntilLoop}min until potential duplicates at current speed`);
        }

        // Load content for dopamine mode with progress tracking (used on initial activation)
        async function loadMoreForDopamineWithProgress() {
            const oldCount = allGifs.length;

            updateLoadingStatus('GATHERING DOPAMINE FEEDS...');
            updateLoadingProgress(20);

            // Collect all fetch promises
            const quickFetches = [];
            let totalFetches = 0;

            // Random Tenor searches (multiple terms for more variety)
            if (sourcesEnabled.tenor) {
                const randomTerms = ['art', 'loop', 'trippy', 'neon', 'abstract', 'psychedelic', 'weird', 'crazy', 'glitch', 'aesthetic', 'surreal', 'hypnotic'];
                for (let i = 0; i < 3; i++) {
                    const term = randomTerms[Math.floor(Math.random() * randomTerms.length)];
                    quickFetches.push(
                        fetch(`https://tenor.googleapis.com/v2/search?q=${term}&key=${TENOR_KEY}&limit=50&media_filter=gif&pos=${Math.floor(Math.random() * 200)}`)
                            .then(r => r.json())
                            .catch(() => ({ results: [] }))
                    );
                    totalFetches++;
                }
            }

            // Random Giphy searches (multiple terms for more variety)
            if (sourcesEnabled.giphy) {
                const randomTerms = ['glitch', 'abstract', 'trippy', 'neon', 'retro', 'vaporwave', 'pixel', 'loop', 'animation', 'art', 'digital', 'psychedelic'];
                for (let i = 0; i < 3; i++) {
                    const term = randomTerms[Math.floor(Math.random() * randomTerms.length)];
                    quickFetches.push(
                        fetch(`https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_KEY}&q=${term}&limit=50&offset=${Math.floor(Math.random() * 200)}&rating=${sfwMode ? 'pg-13' : 'r'}`)
                            .then(r => r.json())
                            .catch(() => ({ data: [] }))
                    );
                    totalFetches++;
                }
            }

            updateLoadingStatus('FETCHING ' + totalFetches + ' FEEDS...');
            updateLoadingProgress(40);

            const results = await Promise.all(quickFetches);

            updateLoadingStatus('PROCESSING DOPAMINE CONTENT...');
            updateLoadingProgress(70);

            // Process and add new gifs using Set for O(1) dedup
            results.forEach((data, index) => {
                const progress = 70 + Math.round((index / results.length) * 20);
                updateLoadingProgress(progress);

                if (data.results) {
                    // Tenor
                    data.results.forEach(item => {
                        const baseId = 'tenor_' + item.id;
                        if (!gifIdSet.has(baseId)) {
                            gifIdSet.add(baseId);
                            allGifs.push({
                                id: baseId + '_' + Date.now(),
                                title: item.content_description || 'Untitled',
                                username: item.itemurl ? new URL(item.itemurl).pathname.split('/')[1] : 'Unknown',
                                tags: item.tags || [],
                                source: 'Tenor',
                                images: {
                                    fixed_height: { url: item.media_formats?.gif?.url || item.media_formats?.tinygif?.url },
                                    original: { url: item.media_formats?.gif?.url }
                                }
                            });
                        }
                    });
                }
                if (data.data && Array.isArray(data.data)) {
                    // Giphy
                    data.data.forEach(item => {
                        const baseId = 'giphy_' + item.id;
                        if (!gifIdSet.has(baseId)) {
                            gifIdSet.add(baseId);
                            allGifs.push({
                                id: baseId + '_' + Date.now(),
                                title: item.title || 'Untitled',
                                username: item.username || item.user?.username || 'Unknown',
                                tags: item.tags || [],
                                source: 'Giphy',
                                images: {
                                    fixed_height: { url: item.images?.fixed_height?.url },
                                    original: { url: item.images?.original?.url }
                                }
                            });
                        }
                    });
                }
            });

            // Cap array size to prevent memory bloat
            if (allGifs.length > MAX_GIFS) {
                const removed = allGifs.splice(0, allGifs.length - MAX_GIFS);
                removed.forEach(g => {
                    const baseId = g.id.split('_').slice(0, 2).join('_');
                    gifIdSet.delete(baseId);
                });
            }

            // Shuffle to mix new content in
            allGifs.sort(() => Math.random() - 0.5);

            updateLoadingStatus('LOADED ' + (allGifs.length - oldCount) + ' NEW ARTWORKS');
            updateLoadingProgress(100);

            console.log(`Dopamine boost: Added ${allGifs.length - oldCount} new items, total: ${allGifs.length} (capped at ${MAX_GIFS})`);
        }

        function updateWeight(source, value) {
            sourceWeights[source] = parseFloat(value);
            document.getElementById('weight_' + source).textContent = value + 'x';
        }

        function allSourcesOn() {
            Object.keys(sourcesEnabled).forEach(s => {
                // Skip coming soon sources
                if (!comingSoonSources.includes(s)) {
                    sourcesEnabled[s] = true;
                }
            });
            renderSourceToggles();
            renderSourceControls();
            updatePendingChangesIndicator();
        }

        function allSourcesOff() {
            // Keep at least one source enabled
            const firstSource = Object.keys(sourcesEnabled)[0];
            Object.keys(sourcesEnabled).forEach(s => sourcesEnabled[s] = false);
            sourcesEnabled[firstSource] = true;
            renderSourceToggles();
            renderSourceControls();
            updatePendingChangesIndicator();
        }

        function objktOnly() {
            // Turn off all sources except objkt
            Object.keys(sourcesEnabled).forEach(s => sourcesEnabled[s] = false);
            sourcesEnabled.objkt = true;
            // Ensure objkt weight is at least 1
            if (sourceWeights.objkt < 1) sourceWeights.objkt = 1;
            console.log('objktOnly: enabled objkt, weight:', sourceWeights.objkt);
            renderSourceToggles();
            renderSourceControls();
            applyFilters(); // Preset auto-applies
        }

        function toggleRedditSub(sub) {
            if (redditSubs.includes(sub)) {
                redditSubs = redditSubs.filter(s => s !== sub);
            } else {
                redditSubs.push(sub);
            }
            renderRedditTags();
            updatePendingChangesIndicator();
        }

        function renderRedditTags() {
            const container = document.getElementById('redditTags');
            container.innerHTML = allRedditSubs.map(sub => `
                <span class="filter-tag ${redditSubs.includes(sub) ? 'active' : ''}"
                      onclick="event.stopPropagation(); toggleRedditSub('${sub}')">r/${sub}</span>
            `).join('');

            // Easter egg step 2: Show secret subreddit when egg is found
            if (easterEggState.eggFound) {
                container.innerHTML += `
                    <span class="filter-tag secret-reveal" onclick="clickSecretSub()"
                          style="background:rgba(0,255,0,0.1);border-color:#00ff00;color:#00ff00;margin-left:10px;">
                        r/notasecret
                    </span>
                `;
            }
        }

        function allSubredditsOn() {
            redditSubs = [...allRedditSubs];
            renderRedditTags();
            updatePendingChangesIndicator();
        }

        function allSubredditsOff() {
            redditSubs = [];
            renderRedditTags();
            updatePendingChangesIndicator();
        }

        function addCustomSubreddit() {
            const input = document.getElementById('customSubreddit');
            let sub = input.value.trim();
            // Remove r/ prefix if user included it
            if (sub.startsWith('r/')) sub = sub.substring(2);
            if (sub && !allRedditSubs.includes(sub)) {
                allRedditSubs.push(sub);
                redditSubs.push(sub);
                renderRedditTags();
                updatePendingChangesIndicator();
            } else if (sub && !redditSubs.includes(sub)) {
                redditSubs.push(sub);
                renderRedditTags();
                updatePendingChangesIndicator();
            }
            input.value = '';
        }

        function renderArtistTags() {
            const container = document.getElementById('artistTags');
            if (!container) return;
            container.innerHTML = allArtists.map(artist => `
                <span class="filter-tag ${selectedArtists.includes(artist) ? 'active' : ''}"
                      onclick="event.stopPropagation(); toggleArtist('${artist.replace(/'/g, "\\'")}')">${artist}</span>
            `).join('');
        }

        function toggleArtist(artist) {
            if (selectedArtists.includes(artist)) {
                selectedArtists = selectedArtists.filter(a => a !== artist);
            } else {
                selectedArtists.push(artist);
            }
            renderArtistTags();
            updatePendingChangesIndicator();
        }

        function allArtistsOn() {
            selectedArtists = [...allArtists];
            renderArtistTags();
            updatePendingChangesIndicator();
        }

        function allArtistsOff() {
            selectedArtists = [];
            renderArtistTags();
            updatePendingChangesIndicator();
        }

        function addCustomFilter() {
            const input = document.getElementById('customFilter');
            const term = input.value.trim();
            if (term && !allSearchTerms.includes(term)) {
                allSearchTerms.push(term);
                searchTerms.push(term);
            } else if (term && !searchTerms.includes(term)) {
                searchTerms.push(term);
            }
            input.value = '';
            renderFilterTags();
            updatePendingChangesIndicator();
        }

        // === SAVED PRESETS ===
        function getSavedPresets() {
            try {
                return JSON.parse(localStorage.getItem('gg_saved_presets') || '[]');
            } catch (e) {
                return [];
            }
        }

        function saveSavedPresets(presetsList) {
            localStorage.setItem('gg_saved_presets', JSON.stringify(presetsList));
        }

        function saveCurrentPreset() {
            const name = prompt('Enter a name for this preset:');
            if (!name || !name.trim()) return;

            const preset = {
                name: name.trim(),
                sources: {...sourcesEnabled},
                filters: [...searchTerms],
                artists: [...selectedArtists],
                subreddits: [...redditSubs],
                timestamp: Date.now()
            };

            const savedPresets = getSavedPresets();
            savedPresets.push(preset);
            saveSavedPresets(savedPresets);
            renderSavedPresets();
        }

        function loadSavedPreset(index) {
            const savedPresets = getSavedPresets();
            const preset = savedPresets[index];
            if (!preset) return;

            // Restore all settings
            Object.keys(sourcesEnabled).forEach(s => {
                sourcesEnabled[s] = preset.sources[s] || false;
            });
            searchTerms = preset.filters || [];
            selectedArtists = preset.artists || [];
            redditSubs = preset.subreddits || [];

            // Update UI
            renderSourceToggles();
            renderSourceControls();
            renderFilterTags();
            renderArtistTags();
            renderRedditTags();

            // Apply
            applyFilters();
        }

        function deleteSavedPreset(index) {
            if (!confirm('Delete this preset?')) return;

            const savedPresets = getSavedPresets();
            savedPresets.splice(index, 1);
            saveSavedPresets(savedPresets);
            renderSavedPresets();
        }

        function renderSavedPresets() {
            const container = document.getElementById('savedPresetsContainer');
            if (!container) return;

            const savedPresets = getSavedPresets();

            if (savedPresets.length === 0) {
                container.innerHTML = '<span style="color:#666;font-size:0.8rem;">No saved presets yet</span>';
                return;
            }

            container.innerHTML = savedPresets.map((preset, i) => `
                <span class="filter-tag" style="display:inline-flex;align-items:center;gap:5px;">
                    <span onclick="loadSavedPreset(${i})" style="cursor:pointer;">${preset.name}</span>
                    <span onclick="deleteSavedPreset(${i})" style="cursor:pointer;color:#ff6464;font-weight:bold;" title="Delete">&times;</span>
                </span>
            `).join('');
        }

        function applyFilters() {
            // Check for easter egg completion before applying
            if (checkEasterEggComplete()) {
                triggerMatrixEffect();
                // Still close the panel
                document.getElementById('filterPanel').classList.remove('active');
                hidePendingChangesIndicator();
                return; // Don't actually apply filters, just show the effect
            }

            document.getElementById('filterPanel').classList.remove('active');
            hidePendingChangesIndicator();
            allGifs = [];
            clearDedupCaches(); // Clear URL and ID tracking for fresh content
            scrollPos = 0;
            // Clear dopamine interval if running to prevent race conditions
            if (dopamineRefreshInterval) {
                clearInterval(dopamineRefreshInterval);
                dopamineRefreshInterval = null;
            }
            document.getElementById('scrollTrack').innerHTML = '<div class="loading">Loading art...</div>';
            loadGifs().then(() => {
                // Restart dopamine interval if mode is active
                if (dopamineMode && (sourcesEnabled.tenor || sourcesEnabled.giphy)) {
                    dopamineRefreshInterval = setInterval(() => {
                        loadMoreForDopamine();
                    }, 30000);
                }
            });
        }

        // === EASTER EGG HUNT ===
        function clickEasterEgg() {
            if (!easterEggState.eggFound) {
                easterEggState.eggFound = true;
                // Reveal the secret subreddit
                renderRedditTags();
                // Little feedback
                const btn = event.target;
                btn.style.color = '#00ff00';
                btn.style.borderColor = '#00ff00';
                btn.style.opacity = '1';
                btn.textContent = 'ðŸ¥š Found!';
            }
        }

        function clickSecretSub() {
            if (easterEggState.eggFound && !easterEggState.secretSubFound) {
                easterEggState.secretSubFound = true;
                // Reveal the secret source
                renderSourceToggles();
                // Feedback
                const btn = event.target;
                btn.style.animation = 'secret-glow 0.5s ease';
            }
        }

        function clickSecretSource() {
            if (easterEggState.secretSubFound && !easterEggState.shhhFound) {
                easterEggState.shhhFound = true;
                // All pieces found!
                const btn = event.target;
                btn.style.animation = 'secret-glow 0.5s ease';
                btn.textContent = 'ðŸ¤« Ready...';
            }
        }

        function checkEasterEggComplete() {
            return easterEggState.eggFound && easterEggState.secretSubFound && easterEggState.shhhFound;
        }

        function triggerMatrixEffect() {
            const container = document.getElementById('matrixContainer');
            const canvas = document.getElementById('matrixCanvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Matrix rain characters
            const chars = 'GLITCHGALLERY01ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒãƒŽãƒãƒ’ãƒ•ãƒ˜ãƒ›ãƒžãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ²ãƒ³';
            const fontSize = 16;
            const columns = canvas.width / fontSize;
            const drops = [];

            for (let i = 0; i < columns; i++) {
                drops[i] = Math.random() * -100;
            }

            // Show container
            container.classList.add('active');

            // Animation
            let frameCount = 0;
            const maxFrames = 300; // ~5 seconds at 60fps

            function drawMatrix() {
                // Semi-transparent black to create trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Green text
                ctx.fillStyle = '#00ff00';
                ctx.font = fontSize + 'px monospace';

                for (let i = 0; i < drops.length; i++) {
                    const char = chars[Math.floor(Math.random() * chars.length)];
                    ctx.fillText(char, i * fontSize, drops[i] * fontSize);

                    // Reset drop to top with random delay
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    drops[i]++;
                }

                frameCount++;
                if (frameCount < maxFrames) {
                    requestAnimationFrame(drawMatrix);
                } else {
                    // Fade out and cleanup
                    container.classList.add('fade-out');
                    setTimeout(() => {
                        container.classList.remove('active', 'fade-out');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        // Reset easter egg state for replay
                        easterEggState = { eggFound: false, secretSubFound: false, shhhFound: false };
                        renderSourceToggles();
                        renderRedditTags();
                    }, 500);
                }
            }

            drawMatrix();
        }

        // Welcome popup for first-time visitors
        function showWelcomePopup() {
            // Only show once per device
            if (localStorage.getItem('gg_welcomed') === 'true') return;

            const modal = document.createElement('div');
            modal.id = 'welcomeModal';
            modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.95);z-index:6000;display:flex;justify-content:center;align-items:center;padding:20px;';
            modal.innerHTML = `
                <div style="background:linear-gradient(135deg, #1a1a2e 0%, #0a0a0a 100%);border:2px solid #8338ec;border-radius:16px;padding:30px;max-width:500px;text-align:center;box-shadow:0 0 50px rgba(131,56,236,0.3);">
                    <h2 style="color:#8338ec;margin-bottom:20px;font-size:1.8rem;">Welcome to GlitchGallery</h2>
                    <p style="color:#ccc;margin-bottom:20px;line-height:1.7;font-size:0.95rem;">
                        This gallery shows art from multiple sources including GIFs, animations, and NFTs.
                        Some content may contain <strong style="color:#fff;">flashing images or rapid movement</strong>.
                    </p>
                    <div style="background:rgba(46,204,113,0.15);border:1px solid #2ecc71;border-radius:10px;padding:15px;margin-bottom:20px;">
                        <p style="color:#2ecc71;margin:0;font-size:0.9rem;">
                            <strong>Seizure Safe Mode</strong> is available in the top navigation bar.
                            It reduces flashing, shows static images, and filters strobe content.
                        </p>
                    </div>
                    <div style="background:rgba(58,134,255,0.15);border:1px solid #3a86ff;border-radius:10px;padding:15px;margin-bottom:25px;">
                        <p style="color:#3a86ff;margin:0;font-size:0.9rem;">
                            <strong>Safe For Work</strong> mode is on by default. NSFW content requires confirmation.
                        </p>
                    </div>
                    <button onclick="closeWelcomePopup()" style="background:#8338ec;color:#fff;border:none;padding:15px 40px;border-radius:10px;cursor:pointer;font-size:1.1rem;font-weight:bold;transition:all 0.2s;">
                        Got it, let's explore!
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function closeWelcomePopup() {
            localStorage.setItem('gg_welcomed', 'true');
            const modal = document.getElementById('welcomeModal');
            if (modal) modal.remove();
        }

        // Init
        updateSavedCount();
        applySeizureSafeMode(); // Apply seizure safe mode on load (checks localStorage and prefers-reduced-motion)
        applySfwMode(); // Apply SFW mode on load (SFW by default)
        setupScroll();
        renderSourceToggles();
        renderSourceControls();
        renderArtWheel(); // Render the Art Wheel presets
        renderFilterTags();
        renderArtistTags();
        renderRedditTags();
        renderSavedPresets(); // Load saved presets
        showWelcomePopup(); // Show welcome for first-time visitors
        loadGifs();
    </script>
</body>
</html>
